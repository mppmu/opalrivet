diff -Naur -x '*Makefile.in*' -x 'acloc*' ./include/YODA/Makefile.am ./include/YODA/Makefile.am
--- ./include/YODA/Makefile.am	2013-08-16 00:10:22.000000000 +0200
+++ ./include/YODA/Makefile.am	2014-04-12 01:31:24.713212521 +0200
@@ -14,7 +14,7 @@
     Scatter3D.h Point3D.h \
     ScatterND.h PointND.h ErrorND.h \
     Writer.h WriterAIDA.h WriterFLAT.h WriterYODA.h \
-    Reader.h ReaderAIDA.h ReaderYODA.h ReaderFLAT.h \
+    Reader.h ReaderAIDA.h ReaderYODA.h ReaderFLAT.h ReaderROOT.h\
     IO.h ROOTCnv.h
 
 nobase_pkginclude_HEADERS = \
diff -Naur -x '*Makefile.in*' -x 'acloc*' ./include/YODA/ReaderROOT.h ./include/YODA/ReaderROOT.h
--- ./include/YODA/ReaderROOT.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/YODA/ReaderROOT.h	2014-04-12 01:26:42.005025549 +0200
@@ -0,0 +1,165 @@
+// -*- C++ -*-
+//
+// This file is part of YODA -- Yet more Objects for Data Analysis
+//Andrii Verbytskyi, 2014
+//
+#ifndef YODA_READERROOT_H
+#define YODA_READERROOT_H
+
+#include "YODA/AnalysisObject.h"
+#include "YODA/Reader.h"
+#include <YODA/Scatter2D.h>
+#include <boost/spirit/include/qi.hpp>
+#include <boost/spirit/include/phoenix_operator.hpp>
+#include <boost/fusion/include/adapt_struct.hpp>
+
+namespace YODA {
+
+  using namespace boost::spirit;
+  using namespace boost::phoenix;
+
+
+  /// Persistency reader from YODA flat text data format.
+  class ReaderROOT : public Reader {
+  public:
+
+    /// Singleton creation function
+    static Reader& create() {
+      static ReaderROOT _instance;
+      return _instance;
+    }
+
+    void read(std::istream& stream, std::vector<AnalysisObject*>& aos) {
+      _readDoc(stream, aos);
+    }
+
+
+    // Hide from Doxygen until endcond
+    /// @cond
+
+
+  protected:
+
+    void _readDoc(std::istream& stream, std::vector<AnalysisObject*>& aos);
+
+  private:
+
+    void cleanup() {
+      _scatter2d.points.clear();
+
+      _annotations.clear();
+    }
+
+  public:
+
+    /// Private constructor, since it's a singleton.
+    /// @todo This is definitely not private!
+
+    ReaderROOT() { }
+
+    // Here comes everything we need for the parser
+
+    /// Structs for the flat HISTOGRAM parser
+    /// The data for a flat HISTOGRAM bin
+    struct histogrampointsymmetric1d {
+      double xmin;
+      double xmax;
+      double y;
+      double ey;
+    };
+
+    struct histogrampointasymmetric1d {
+      double xmin;
+      double xmax;
+      double y;
+      double eyminus;
+      double eyplus;
+    };
+
+    /// Structs for the key-value pair parser (annotations)
+    struct keyval {
+      std::string key;
+      std::string val;
+    };
+
+
+    /// Annotations (common for all data types)
+    static std::map<std::string, std::string> _annotations;
+
+
+    /// All information for creating a Scatter2D from a flat HISTOGRAM
+    struct scatter2d {
+      std::vector<YODA::Point2D> points;
+    };
+    static scatter2d _scatter2d;
+
+
+    /// Functions to call from the parser
+
+
+    /// Filling a point
+    struct fillpoint {
+      void operator()(const histogrampointsymmetric1d p, qi::unused_type, qi::unused_type) const {
+        double x  = 0.5*(p.xmin+p.xmax);
+        double ex = 0.5*(p.xmax-p.xmin);
+        YODA::Point2D point(x, p.y, ex, ex, p.ey, p.ey);
+        _scatter2d.points.push_back(point);
+      }
+      void operator()(const histogrampointasymmetric1d p, qi::unused_type, qi::unused_type) const {
+        double x  = 0.5*(p.xmin+p.xmax);
+        double ex = 0.5*(p.xmax-p.xmin);
+        YODA::Point2D point(x, p.y, ex, ex, p.eyminus, p.eyplus);
+        _scatter2d.points.push_back(point);
+      }
+    };
+
+
+    /// Filling the annotations map
+    struct fillkeyval {
+      void operator()(const keyval m, qi::unused_type, qi::unused_type) const {
+        _annotations[m.key] = m.val;
+      }
+    };
+
+
+
+/// @endcond
+
+};
+
+} // end of YODA namespace
+
+
+
+// Now we need to make boost aware of the structs we want to
+// fill directly from the parser. Boost wants this magic in
+// the global scope, that's why we have it outside the namespace.
+
+/// @cond PRIVATE
+
+BOOST_FUSION_ADAPT_STRUCT(
+  YODA::ReaderROOT::histogrampointsymmetric1d,
+  (double, xmin)
+  (double, xmax)
+  (double, y)
+  (double, ey)
+)
+
+BOOST_FUSION_ADAPT_STRUCT(
+  YODA::ReaderROOT::histogrampointasymmetric1d,
+  (double, xmin)
+  (double, xmax)
+  (double, y)
+  (double, eyminus)
+  (double, eyplus)
+)
+
+BOOST_FUSION_ADAPT_STRUCT(
+  YODA::ReaderROOT::keyval,
+  (std::string, key)
+  (std::string, val)
+)
+
+/// @endcond
+
+#endif
diff -Naur -x '*Makefile.in*' -x 'acloc*' ./src/Makefile.am ./src/Makefile.am
--- ./src/Makefile.am	2013-10-24 21:06:20.000000000 +0200
+++ ./src/Makefile.am	2014-04-12 01:31:19.401280345 +0200
@@ -6,6 +6,7 @@
 libYODA_la_SOURCES = \
     Reader.cc \
     ReaderYODA.cc \
+    ReaderROOT.cc \
     ReaderAIDA.cc \
     ReaderFLAT.cc \
     Writer.cc \
@@ -21,6 +22,6 @@
     Scatter2D.cc \
     Scatter3D.cc
 
-libYODA_la_LDFLAGS = -avoid-version
+libYODA_la_LDFLAGS = -avoid-version $(ROOT_LDFLAGS)
 libYODA_la_LIBADD = tinyxml/libtinyxml.la
-libYODA_la_CPPFLAGS = $(AM_CPPFLAGS) -DTIXML_USE_STL
+libYODA_la_CPPFLAGS = $(AM_CPPFLAGS) -DTIXML_USE_STL $(ROOT_CXXFLAGS)
diff -Naur -x '*Makefile.in*' -x 'acloc*' ./src/ReaderROOT.cc ./src/ReaderROOT.cc
--- ./src/ReaderROOT.cc	1970-01-01 01:00:00.000000000 +0100
+++ ./src/ReaderROOT.cc	2014-04-12 01:26:26.221253224 +0200
@@ -0,0 +1,79 @@
+// -*- C++ -*-
+//
+// This file is part of YODA -- Yet more Objects for Data Analysis
+// Copyright (C) 2008-2013 The YODA collaboration (see AUTHORS for details)
+//
+#include "YODA/ReaderROOT.h"
+#include "YODA/Utils/StringUtils.h"
+#include "YODA/Exceptions.h"
+
+#include <iostream>
+
+#include "TFile.h"
+#include "TList.h"
+#include "TKey.h"
+#include "TClass.h"
+#include "TH1F.h"
+
+using namespace std;
+
+namespace YODA {
+
+  ReaderROOT::scatter2d ReaderROOT::_scatter2d;
+  std::map<std::string, std::string> ReaderROOT::_annotations;
+  
+
+  void ReaderROOT::_readDoc(std::istream& stream, vector<AnalysisObject*>& aos) {
+
+    // These are the context groups we know. We need
+    // that map to dynamically change the parser depending
+    // on what we read in.
+    std::map<int, std::string> groups;
+    groups[1] = "HISTOGRAM";
+
+std::string streama("1.root");
+TFile* fin = new TFile(streama.c_str()) ;
+  if (!fin->IsOpen()) {
+    printf("<E> Cannot open input file %s\n",streama.c_str()) ;
+    exit(1) ;
+  }
+  
+  TList* list = fin->GetListOfKeys() ;
+  if (!list) { printf("<E> No keys found in file\n") ; exit(1) ; }
+  TIter next(list) ;
+  TKey* key ;
+  TObject* obj ;
+      
+  while ( key = (TKey*)next() ) {
+    obj = key->ReadObj() ;
+    if (    (strcmp(obj->IsA()->GetName(),"TProfile")!=0)         && (!obj->InheritsFrom("TH2"))	 && (!obj->InheritsFrom("TH1"))  ) 
+    {
+      printf("<W> Object %s is not 1D or 2D histogram : "
+             "will not be converted\n",obj->GetName()) ;
+    }
+    else
+    {
+    printf("Histo name:%s title:%s\n",obj->GetName(),obj->GetTitle());
+    char a[255];
+    sprintf(a,"/%s/%s",obj->GetName(),obj->GetTitle());
+    //	        Scatter2D* dps = new Scatter2D(plotpath + sep + plotname);
+	
+	        Scatter2D* dps = new Scatter2D(a);
+	        int i;
+	        TH1F* HH=(TH1F*)obj;
+	        for (i=1;i<HH->GetNbinsX();i++)
+	        dps->addPoint(HH->GetBinCenter(i), HH->GetBinContent(i),
+	         HH->GetBinCenter(i)- HH->GetBinLowEdge(i),
+	          HH->GetBinLowEdge(i)+ HH->GetBinWidth(i)-HH->GetBinCenter(i),
+	                       HH->GetBinErrorLow(i), HH->GetBinErrorUp(i));
+	//addPoint(xcentre, ycentre, xerrminus, xerrplus, yerrminus, yerrplus);
+            aos.push_back(dps);
+            cleanup();
+    }
+  
+  }
+fin->Close();
+}
+
+
+}
