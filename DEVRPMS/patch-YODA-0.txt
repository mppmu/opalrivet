diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./bin/aida2flat ./bin/aida2flat
--- ./bin/aida2flat	2014-05-12 17:25:39.660318585 +0200
+++ ./bin/aida2flat	1970-01-01 01:00:00.000000000 +0100
@@ -1,21 +0,0 @@
-#! /usr/bin/env python
-
-"""\
-%prog aidafile [flatfile]
-
-Convert an AIDA data file to a 'flat', human-readable data format.
-"""
-
-import yoda, os, sys, optparse
-from yoda.script_helpers import parse_x2y_args
-
-parser = optparse.OptionParser(usage=__doc__)
-opts, args = parser.parse_args()
-in_out = parse_x2y_args(args, ".aida", ".dat")
-if not in_out:
-    sys.stderr.write("You must specify the AIDA and FLAT file names\n")
-    sys.exit(1)
-
-for i, o in in_out:
-    analysisobjects = yoda.readAIDA(i)
-    yoda.writeFLAT(analysisobjects, o)
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./bin/aida2yoda ./bin/aida2yoda
--- ./bin/aida2yoda	2014-05-12 17:25:39.661318577 +0200
+++ ./bin/aida2yoda	1970-01-01 01:00:00.000000000 +0100
@@ -1,21 +0,0 @@
-#! /usr/bin/env python
-
-"""\
-%prog aidafile [yodafile]
-
-Convert an AIDA data file to the YODA data format.
-"""
-
-import yoda, os, sys, optparse
-from yoda.script_helpers import parse_x2y_args
-
-parser = optparse.OptionParser(usage=__doc__)
-opts, args = parser.parse_args()
-in_out = parse_x2y_args(args, ".aida", ".yoda")
-if not in_out:
-    sys.stderr.write("You must specify the AIDA and YODA file names\n")
-    sys.exit(1)
-
-for i, o in in_out:
-    analysisobjects = yoda.readAIDA(i)
-    yoda.writeYODA(analysisobjects, o)
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./bin/flat2yoda ./bin/flat2yoda
--- ./bin/flat2yoda	2014-05-12 17:25:39.661318577 +0200
+++ ./bin/flat2yoda	1970-01-01 01:00:00.000000000 +0100
@@ -1,21 +0,0 @@
-#! /usr/bin/env python
-
-"""\
-%prog flatfile [yodafile]
-
-Convert a FLAT data file to the YODA data format.
-"""
-
-import yoda, os, sys, optparse
-from yoda.script_helpers import parse_x2y_args
-
-parser = optparse.OptionParser(usage=__doc__)
-opts, args = parser.parse_args()
-in_out = parse_x2y_args(args, ".dat", ".yoda")
-if not in_out:
-    sys.stderr.write("You must specify the FLAT and YODA file names\n")
-    sys.exit(1)
-
-for i, o in in_out:
-    analysisobjects = yoda.readFLAT(i)
-    yoda.writeYODA(analysisobjects, o)
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./bin/yoda2aida ./bin/yoda2aida
--- ./bin/yoda2aida	2014-05-12 17:25:39.661318577 +0200
+++ ./bin/yoda2aida	1970-01-01 01:00:00.000000000 +0100
@@ -1,21 +0,0 @@
-#! /usr/bin/env python
-
-"""\
-%prog yodafile [aidafile]
-
-Convert a YODA data file to the old AIDA XML data format.
-"""
-
-import yoda, os, sys, optparse
-from yoda.script_helpers import parse_x2y_args
-
-parser = optparse.OptionParser(usage=__doc__)
-opts, args = parser.parse_args()
-in_out = parse_x2y_args(args, ".yoda", ".aida")
-if not in_out:
-    sys.stderr.write("You must specify the YODA and AIDA file names\n")
-    sys.exit(1)
-
-for i, o in in_out:
-    analysisobjects = yoda.readYODA(i)
-    yoda.writeAIDA(analysisobjects, o)
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./bin/yoda2flat ./bin/yoda2flat
--- ./bin/yoda2flat	2014-05-12 17:25:39.660318585 +0200
+++ ./bin/yoda2flat	1970-01-01 01:00:00.000000000 +0100
@@ -1,21 +0,0 @@
-#! /usr/bin/env python
-
-"""\
-%prog yodafile [flatfile]
-
-Convert a YODA data file to a 'flat', more human-readable data format.
-"""
-
-import yoda, os, sys, optparse
-from yoda.script_helpers import parse_x2y_args
-
-parser = optparse.OptionParser(usage=__doc__)
-opts, args = parser.parse_args()
-in_out = parse_x2y_args(args, ".yoda", ".dat")
-if not in_out:
-    sys.stderr.write("You must specify the YODA and FLAT file names\n")
-    sys.exit(1)
-
-for i, o in in_out:
-    analysisobjects = yoda.readYODA(i)
-    yoda.writeFLAT(analysisobjects, o)
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./bin/yoda2root ./bin/yoda2root
--- ./bin/yoda2root	2014-05-12 17:25:39.659318592 +0200
+++ ./bin/yoda2root	1970-01-01 01:00:00.000000000 +0100
@@ -1,26 +0,0 @@
-#! /usr/bin/env python
-
-"""\
-%prog yodafile [rootfile]
-
-Convert a YODA data file to the ROOT data format.
-"""
-
-import yoda, os, sys, optparse
-from yoda.script_helpers import parse_x2y_args
-
-parser = optparse.OptionParser(usage=__doc__)
-opts, args = parser.parse_args()
-in_out = parse_x2y_args(args, ".yoda", ".root")
-if not in_out:
-    sys.stderr.write("You must specify the YODA and ROOT file names\n")
-    sys.exit(1)
-
-import ROOT
-for i, o in in_out:
-    of = ROOT.TFile(o, "recreate")
-    analysisobjects = yoda.readYODA(i)
-    rootobjects = [yoda.to_root(ao) for ao in analysisobjects.values()]
-    #print rootobjects
-    of.Write()
-    of.Close()
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./bin/yodaconvert.cc ./bin/yodaconvert.cc
--- ./bin/yodaconvert.cc	1970-01-01 01:00:00.000000000 +0100
+++ ./bin/yodaconvert.cc	2014-05-12 17:25:39.703318257 +0200
@@ -0,0 +1,113 @@
+/* AV 2014 */
+#include "YODA/WriterYODA.h"
+#include "YODA/ReaderYODA.h"
+#include "YODA/WriterFLAT.h"
+#include "YODA/ReaderFLAT.h"
+#include "YODA/WriterAIDA.h"
+#include "YODA/ReaderAIDA.h"
+//#include "YODA/WriterROOT.h"
+#include "YODA/ReaderROOT.h"
+#include <cmath>
+#include <vector>
+#include <string>
+#include <functional>
+#include <fstream>
+
+using namespace std;
+using namespace YODA;
+enum formats {yoda, flat, aida, root};
+int main(int argc, char** argv)
+{
+    if (argc<3)
+        {
+            printf("\
+	Usage: %s <mode> <input_file.input_extension>    <output_file.output_extension>, or\n\
+	       %s <mode> <input_file1[.input_extension]> <input_file2[.input_extension]> ...\n\
+	Supported modes are: yoda2flat yoda2aida flat2yoda flat2aida aida2flat aida2yoda root2flat root2aida root2yoda.\n",argv[0],argv[0]);
+            exit(1);
+        }
+    const  std::map<std::string,formats> format_map = { { "yoda", formats::yoda }, { "flat", formats::flat }, { "aida", formats::aida }, { "root", formats::root }       };
+    std::vector<std::pair <std::string,std::string> > convert_list;
+    std::pair<std::string,std::string> convert_formats;
+    std::string mode(argv[1]);
+    int i,j=0;
+    for (i=0; i<mode.size(); i++)
+        if (mode[i]!='2')
+            {
+                if (j==0) convert_formats.first+=mode[i];
+                if (j==1) convert_formats.second+=mode[i];
+                if (j>1)  {printf("Wrong mode string: %s\nMode string should be <format>2<format>.\n",argv[1]); exit(1);}
+            }
+        else j++;
+    if (format_map.find(convert_formats.first )==format_map.end()) { printf("Input format %s is unknown.\n",convert_formats.first.c_str()); exit(2); }
+    if (format_map.find(convert_formats.second)==format_map.end()) { printf("Output format %s is unknown.\n",convert_formats.second.c_str()); exit(2); }
+    if (argc==4)
+        {
+            convert_list.push_back(std::pair<std::string,std::string>(std::string(argv[2]),std::string(argv[3])));
+            if ((convert_list.back().first.substr(convert_list.back().first.find_last_of(".") + 1) != convert_formats.first) ||
+                    (convert_list.back().second.substr(convert_list.back().second.find_last_of(".") + 1) != convert_formats.second))
+                { printf("The conversion mode=%s doesn't match extensions of %s %s files\n",argv[1],argv[2],argv[3]); exit(1);}
+        }
+    else
+        for (i=2; i<argc; i++)
+            {
+                convert_list.push_back(std::pair<std::string,std::string>(std::string(argv[i]),std::string(argv[i])));
+                if (convert_list.back().first.substr(convert_list.back().first.find_last_of(".") + 1) == convert_formats.first)
+                    convert_list.back().second.replace(convert_list.back().second.find_last_of(".") + 1,convert_formats.first.size(), convert_formats.second);
+                else
+                    {
+                        convert_list.back().second+= ".";
+                        convert_list.back().second+=convert_formats.second;
+                    }
+            }
+
+    std::vector<AnalysisObject*> in;
+    for (i=0; i<convert_list.size(); i++)
+        {
+            switch (format_map.at(convert_formats.first))
+                {
+                case formats::yoda:
+                    in=ReaderYODA::create().read(convert_list[i].first);
+                    break;
+                case formats::flat:
+                    in=ReaderFLAT::create().read(convert_list[i].first);
+                    break;
+                case formats::aida:
+                    in=ReaderAIDA::create().read(convert_list[i].first);
+                    break;
+                case formats::root:
+                    in=ReaderROOT::create(convert_list[i].first).read("just_a_place_holder");
+                    break;
+                default:
+                    printf("Input format %s is unknown.\n",convert_formats.first.c_str());
+                    exit(2);
+                    break;
+                }
+
+            ofstream ofile;
+            ofile.open (convert_list[i].second.c_str());
+            switch (format_map.at(convert_formats.second))
+                {
+                case formats::yoda:
+                    for (vector<AnalysisObject*>::const_iterator j = in.begin(); j != in.end(); ++j) YODA::WriterYODA::write(ofile, (**j));
+                    break;
+                case formats::flat:
+                    for (vector<AnalysisObject*>::const_iterator j = in.begin(); j != in.end(); ++j) YODA::WriterFLAT::write(ofile, (**j));
+                    break;
+                case formats::aida:
+                    for (vector<AnalysisObject*>::const_iterator j = in.begin(); j != in.end(); ++j) YODA::WriterAIDA::write(ofile, (**j));
+                    break;
+                case formats::root:
+                    printf("WriterROOT is not implemented yet.\n");
+                    exit(2);
+                    break;
+                default:
+                    printf("Output format %s is unknown.\n",convert_formats.second.c_str());
+                    exit(2);
+                    break;
+                }
+            ofile.close();
+        }
+
+    exit(0);
+}
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./include/YODA/ReaderROOT.h ./include/YODA/ReaderROOT.h
--- ./include/YODA/ReaderROOT.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/YODA/ReaderROOT.h	2014-05-12 17:25:39.718318142 +0200
@@ -0,0 +1,299 @@
+// -*- C++ -*-
+//
+// This file is part of YODA -- Yet more Objects for Data Analysis
+//Andrii Verbytskyi, 2014
+//
+#ifndef YODA_READERROOT_H
+#define YODA_READERROOT_H
+
+#include "YODA/AnalysisObject.h"
+#include "YODA/Reader.h"
+#include "YODA/ROOTCnv.h"
+#include <YODA/Scatter2D.h>
+#include <boost/spirit/include/qi.hpp>
+#include <boost/spirit/include/phoenix_operator.hpp>
+#include <boost/fusion/include/adapt_struct.hpp>
+
+
+namespace YODA {
+
+  using namespace boost::spirit;
+  using namespace boost::phoenix;
+
+
+  /// Persistency reader from YODA flat text data format.
+  class ReaderROOT : public Reader {
+  public:
+
+    /// Singleton creation function
+    static Reader& create() {
+      static ReaderROOT _instance;
+      return _instance;
+    }
+
+    static Reader& create(std::string filename) {
+      static ReaderROOT _instance(filename);      
+      return _instance;
+    }
+
+
+    void read(std::istream& stream, std::vector<AnalysisObject*>& aos) {
+      _readDoc(stream, aos);
+    }
+
+
+
+    // Hide from Doxygen until endcond
+    /// @cond
+
+
+  protected:
+
+    void _readDoc(std::istream& stream, std::vector<AnalysisObject*>& aos);
+
+
+  private:
+std::string _filename;
+    void cleanup() {
+      _histo1d.bins.clear();
+      _histo1d.dbn_tot.reset();
+      _histo1d.dbn_uflow.reset();
+      _histo1d.dbn_oflow.reset();
+
+      _profile1d.bins.clear();
+      _profile1d.dbn_tot.reset();
+      _profile1d.dbn_uflow.reset();
+      _profile1d.dbn_oflow.reset();
+
+      _scatter2d.points.clear();
+
+      _annotations.clear();
+    }
+
+  public:
+
+    /// Private constructor, since it's a singleton.
+    /// @todo This is definitely not private!
+
+    ReaderROOT() { }
+    ReaderROOT(std::string filename) {_filename=filename;}
+
+   // Here comes everything we need for the parser
+
+    /// Structs for the Histo1D parser
+    /// The data for Dbn1D
+    struct histo1ddbn {
+      double sumW;
+      double sumW2;
+      double sumWX;
+      double sumWX2;
+      unsigned long numFills;
+    };
+
+    /// A Histo1D bin
+    struct histo1dbin {
+      double lowedge;
+      double highedge;
+      histo1ddbn dbn;
+    };
+
+    /// Structs for the Profile1D parser
+    /// The data for Dbn2D (except sumWXY)
+    struct profile1ddbn {
+      double sumW;
+      double sumW2;
+      double sumWX;
+      double sumWX2;
+      double sumWY;
+      double sumWY2;
+      unsigned long numFills;
+    };
+
+    /// A Profile1D bin
+    struct profile1dbin {
+      double lowedge;
+      double highedge;
+      profile1ddbn dbn;
+    };
+
+    /// Structs for the Scatter2D parser
+    /// The data for ScatterPoint2D
+    struct scatterpoint2d {
+      double x;
+      double exminus;
+      double explus;
+      double y;
+      double eyminus;
+      double eyplus;
+    };
+
+    /// Structs for the key-value pair parser (annotations)
+    struct keyval {
+      std::string key;
+      std::string val;
+    };
+
+
+    /// Annotations (common for all data types)
+    static std::map<std::string, std::string> _annotations;
+
+
+    /// All information for creating a Histo1D
+    struct histo1d {
+      std::vector<YODA::HistoBin1D> bins;
+      YODA::Dbn1D dbn_tot;
+      YODA::Dbn1D dbn_uflow;
+      YODA::Dbn1D dbn_oflow;
+    };
+    static histo1d _histo1d;
+
+
+    /// All information for creating a Profile1D
+    struct profile1d {
+      std::vector<YODA::ProfileBin1D> bins;
+      YODA::Dbn2D dbn_tot;
+      YODA::Dbn2D dbn_uflow;
+      YODA::Dbn2D dbn_oflow;
+    };
+    static profile1d _profile1d;
+
+
+    /// All information for creating a Scatter2D
+    struct scatter2d {
+      std::vector<YODA::Point2D> points;
+    };
+    static scatter2d _scatter2d;
+
+
+    /// Functions to call from the parser
+    /// Filling the dbn_tot
+    struct filltotaldbn {
+      void operator()(const histo1ddbn dbn, qi::unused_type, qi::unused_type) const {
+        _histo1d.dbn_tot = YODA::Dbn1D(dbn.numFills, dbn.sumW, dbn.sumW2, dbn.sumWX, dbn.sumWX2);
+      }
+      void operator()(const profile1ddbn dbn, qi::unused_type, qi::unused_type) const {
+        _profile1d.dbn_tot = YODA::Dbn2D(dbn.numFills, dbn.sumW, dbn.sumW2, dbn.sumWX, dbn.sumWX2, dbn.sumWY, dbn.sumWY2, 0.0);
+      }
+    };
+
+
+    /// Filling the underflow
+    struct filluflowdbn {
+      void operator()(const histo1ddbn dbn, qi::unused_type, qi::unused_type) const {
+        _histo1d.dbn_uflow = YODA::Dbn1D(dbn.numFills, dbn.sumW, dbn.sumW2, dbn.sumWX, dbn.sumWX2);
+      }
+      void operator()(const profile1ddbn dbn, qi::unused_type, qi::unused_type) const {
+        _profile1d.dbn_uflow = YODA::Dbn2D(dbn.numFills, dbn.sumW, dbn.sumW2, dbn.sumWX, dbn.sumWX2, dbn.sumWY, dbn.sumWY2, 0.0);
+      }
+    };
+
+
+    /// Filling the overflow
+    struct filloflowdbn {
+      void operator()(const histo1ddbn dbn, qi::unused_type, qi::unused_type) const {
+        _histo1d.dbn_oflow = YODA::Dbn1D(dbn.numFills, dbn.sumW, dbn.sumW2, dbn.sumWX, dbn.sumWX2);
+      }
+      void operator()(const profile1ddbn dbn, qi::unused_type, qi::unused_type) const {
+        _profile1d.dbn_oflow = YODA::Dbn2D(dbn.numFills, dbn.sumW, dbn.sumW2, dbn.sumWX, dbn.sumWX2, dbn.sumWY, dbn.sumWY2, 0.0);
+      }
+    };
+
+
+    /// Filling a bin
+    struct fillbin {
+      void operator()(const histo1dbin b, qi::unused_type, qi::unused_type) const {
+        YODA::HistoBin1D bin(std::make_pair(b.lowedge, b.highedge), YODA::Dbn1D(b.dbn.numFills, b.dbn.sumW, b.dbn.sumW2, b.dbn.sumWX, b.dbn.sumWX2));
+        _histo1d.bins.push_back(bin);
+      }
+      void operator()(const profile1dbin b, qi::unused_type, qi::unused_type) const {
+        YODA::ProfileBin1D bin(std::make_pair(b.lowedge, b.highedge), YODA::Dbn2D(b.dbn.numFills, b.dbn.sumW, b.dbn.sumW2, b.dbn.sumWX, b.dbn.sumWX2, b.dbn.sumWY, b.dbn.sumWY2, 0.0));
+        _profile1d.bins.push_back(bin);
+      }
+    };
+
+
+    /// Filling a point
+    struct fillpoint {
+      void operator()(const scatterpoint2d p, qi::unused_type, qi::unused_type) const {
+        YODA::Point2D point(p.x, p.y, p.exminus, p.explus, p.eyminus, p.eyplus);
+        _scatter2d.points.push_back(point);
+      }
+    };
+
+
+    /// Filling the annotations map
+    struct fillkeyval {
+      void operator()(const keyval m, qi::unused_type, qi::unused_type) const {
+        _annotations[m.key] = m.val;
+      }
+    };
+
+
+
+/// @endcond
+
+};
+
+} // end of YODA namespace
+
+
+
+// Now we need to make boost aware of the structs we want to
+// fill directly from the parser. Boost wants this magic in
+// the global scope, that's why we have it outside the namespace.
+
+/// @cond PRIVATE
+
+BOOST_FUSION_ADAPT_STRUCT(
+  YODA::ReaderROOT::histo1ddbn,
+  (double, sumW)
+  (double, sumW2)
+  (double, sumWX)
+  (double, sumWX2)
+  (unsigned long, numFills)
+)
+
+BOOST_FUSION_ADAPT_STRUCT(
+  YODA::ReaderROOT::histo1dbin,
+  (double, lowedge)
+  (double, highedge)
+  (YODA::ReaderROOT::histo1ddbn, dbn)
+)
+
+BOOST_FUSION_ADAPT_STRUCT(
+  YODA::ReaderROOT::profile1ddbn,
+  (double, sumW)
+  (double, sumW2)
+  (double, sumWX)
+  (double, sumWX2)
+  (double, sumWY)
+  (double, sumWY2)
+  (unsigned long, numFills)
+)
+
+BOOST_FUSION_ADAPT_STRUCT(
+  YODA::ReaderROOT::profile1dbin,
+  (double, lowedge)
+  (double, highedge)
+  (YODA::ReaderROOT::profile1ddbn, dbn)
+)
+
+BOOST_FUSION_ADAPT_STRUCT(
+  YODA::ReaderROOT::scatterpoint2d,
+  (double, x)
+  (double, exminus)
+  (double, explus)
+  (double, y)
+  (double, eyminus)
+  (double, eyplus)
+)
+
+BOOST_FUSION_ADAPT_STRUCT(
+  YODA::ReaderROOT::keyval,
+  (std::string, key)
+  (std::string, val)
+)
+
+/// @endcond
+
+#endif
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./include/YODA/ROOTCnv.h ./include/YODA/ROOTCnv.h
--- ./include/YODA/ROOTCnv.h	2014-05-12 17:25:39.588319135 +0200
+++ ./include/YODA/ROOTCnv.h	2014-05-12 17:25:39.717318150 +0200
@@ -15,6 +15,11 @@
 #include "TProfile.h"
 #include "TGraphAsymmErrors.h"
 #include "TVectorF.h"
+#include "TFile.h"
+#include "TList.h"
+#include "TKey.h"
+#include "TClass.h"
+#include "TH1F.h"
 
 namespace YODA {
 
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./pyext/yoda/core.pyx ./pyext/yoda/core.pyx
--- ./pyext/yoda/core.pyx	2014-05-12 17:25:39.637318760 +0200
+++ ./pyext/yoda/core.pyx	2014-05-12 17:25:39.749317906 +0200
@@ -32,5 +32,5 @@
 include "include/HistoBin2D.pyx"
 include "include/Histo2D.pyx"
 include "include/Profile2D.pyx"
-include "include/Functions.pyx"
+##include "include/Functions.pyx"
 include "include/IO.pyx"
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./pyext/yoda/declarations.pxd ./pyext/yoda/declarations.pxd
--- ./pyext/yoda/declarations.pxd	2014-05-12 17:25:39.630318814 +0200
+++ ./pyext/yoda/declarations.pxd	2014-05-12 17:25:39.748317913 +0200
@@ -969,6 +969,9 @@
 cdef extern from "YODA/ReaderFLAT.h" namespace "YODA":
     Reader& ReaderFLAT_create "YODA::ReaderFLAT::create" ()
 
+cdef extern from "YODA/ReaderROOT.h" namespace "YODA":
+    Reader& ReaderROOT_create "YODA::ReaderROOT::create" ()
+
 cdef extern from "YODA/ReaderAIDA.h" namespace "YODA":
     Reader& ReaderAIDA_create "YODA::ReaderAIDA::create" ()
 
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./pyext/yoda/Makefile.am ./pyext/yoda/Makefile.am
--- ./pyext/yoda/Makefile.am	2014-05-12 17:25:39.607318989 +0200
+++ ./pyext/yoda/Makefile.am	2014-05-12 17:25:39.732318035 +0200
@@ -40,6 +40,10 @@
     mktemplates \
     core.cpp core.h util.cpp
 
+if ENABLE_ROOT
+  CXXFLAGS += $(ROOT_CXXFLAGS) -Wno-long-long 
+endif
+
 
 if WITH_CYTHON
 core.cpp: $(CYTHON_SRC)
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./pyext/yoda/mktemplates ./pyext/yoda/mktemplates
--- ./pyext/yoda/mktemplates	2014-05-12 17:25:39.631318806 +0200
+++ ./pyext/yoda/mktemplates	2014-05-12 17:25:39.749317906 +0200
@@ -50,9 +50,9 @@
     #print plain_name
 
     try:
-        os.mkdir("generated")
+        os.mkdir("include/generated")
     except OSError as exc: # Python >2.5
-        if exc.errno == errno.EEXIST and os.path.isdir("generated"):
+        if exc.errno == errno.EEXIST and os.path.isdir("include/generated"):
             pass
         else: raise
 
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./src/Makefile.am ./src/Makefile.am
--- ./src/Makefile.am	2014-05-12 17:25:39.652318645 +0200
+++ ./src/Makefile.am	2014-05-12 17:25:39.755317860 +0200
@@ -21,6 +21,12 @@
     Scatter2D.cc \
     Scatter3D.cc
 
-libYODA_la_LDFLAGS = -avoid-version
+libYODA_la_LDFLAGS = -avoid-version 
 libYODA_la_LIBADD = tinyxml/libtinyxml.la
-libYODA_la_CPPFLAGS = $(AM_CPPFLAGS) -DTIXML_USE_STL
+libYODA_la_CPPFLAGS = $(AM_CPPFLAGS) -DTIXML_USE_STL 
+
+if  ENABLE_ROOT
+libYODA_la_SOURCES += ReaderROOT.cc 
+libYODA_la_LDFLAGS += $(ROOT_LDFLAGS)
+libYODA_la_CPPFLAGS += $(ROOT_CXXFLAGS) -Wno-long-long 
+endif
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./src/Reader.cc ./src/Reader.cc
--- ./src/Reader.cc	2014-05-12 17:25:39.653318638 +0200
+++ ./src/Reader.cc	2014-05-12 17:25:39.767317768 +0200
@@ -5,22 +5,26 @@
 //
 #include "YODA/Reader.h"
 #include "YODA/ReaderYODA.h"
+#include "YODA/ReaderROOT.h"
 #include "YODA/ReaderAIDA.h"
 #include "YODA/ReaderFLAT.h"
 
 using namespace std;
 
-namespace YODA {
+namespace YODA
+{
 
 
-  Reader& mkReader(const string& name) {
+Reader& mkReader(const string& name)
+{
     const size_t lastdot = name.find_last_of(".");
     const string fmt = boost::to_lower_copy((lastdot == string::npos) ? name : name.substr(lastdot+1));
     if (fmt == "yoda") return ReaderYODA::create();
     if (fmt == "aida") return ReaderAIDA::create();
     if (fmt == "dat")  return ReaderFLAT::create();
+    if (fmt == "root") return ReaderROOT::create(name);
     throw UserError("Format cannot be identified from string '" + name + "'");
-  }
+}
 
 
 }
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./src/ReaderROOT.cc ./src/ReaderROOT.cc
--- ./src/ReaderROOT.cc	1970-01-01 01:00:00.000000000 +0100
+++ ./src/ReaderROOT.cc	2014-05-12 17:25:39.754317867 +0200
@@ -0,0 +1,164 @@
+// -*- C++ -*-
+//
+// This file is part of YODA -- Yet more Objects for Data Analysis
+// Copyright (C) 2008-2013 The YODA collaboration (see AUTHORS for details)
+//
+
+#include "YODA/ReaderROOT.h"
+#include "YODA/Utils/StringUtils.h"
+#include "YODA/Exceptions.h"
+
+#include <iostream>
+
+
+
+using namespace std;
+
+namespace YODA
+{
+ReaderROOT::histo1d ReaderROOT::_histo1d;
+ReaderROOT::profile1d ReaderROOT::_profile1d;
+ReaderROOT::scatter2d ReaderROOT::_scatter2d;
+std::map<std::string, std::string> ReaderROOT::_annotations;
+
+
+
+
+void ReaderROOT::_readDoc(std::istream& stream, vector<AnalysisObject*>& aos)
+{
+
+    std::string streama=_filename; //Ugly trick;
+    TFile* fin = new TFile(streama.c_str()) ;
+    if (!fin->IsOpen())
+        {
+            printf("Cannot open input file %s\n",streama.c_str()) ;
+            exit(1) ;
+        }
+
+    TList* list = fin->GetListOfKeys() ;
+    if (!list) { printf("No keys found in file %s\n",streama.c_str()) ; exit(1) ; }
+
+    TIter next(list) ;
+    TKey* key ;
+    TObject* obj ;
+
+    while ( key = (TKey*)next() )
+        {
+            obj = key->ReadObj() ;
+            int type=-1;
+
+
+
+
+            if (strcmp(obj->IsA()->GetName(),"TProfile")==0) type=0;
+            if (strcmp(obj->IsA()->GetName(),"TH1F")==0)type=11;
+            if (strcmp(obj->IsA()->GetName(),"TH1D")==0) type=12;
+            if (obj->InheritsFrom("TH2")) type=2;
+            if (strcmp(obj->IsA()->GetName(),"TGraph")==0)type=31;
+            if (strcmp(obj->IsA()->GetName(),"TGraphErrors")==0) type=32;
+            if (strcmp(obj->IsA()->GetName(),"TGraphAsymmErrors")==0)type=33;
+            if (type==-1)  printf("Object %s  has unsupported type %s and will not be converted\n",obj->GetName(),obj->IsA()->GetName()) ;
+            if (type==0)   printf("Object %s has unsupported type TProfile\n",obj->GetName()) ;
+            if (type==11||type==12)
+                {
+
+#define TH1_IS_SCATTER2D
+
+#ifdef TH1_IS_SCATTER2D
+                    char a[255];
+                    sprintf(a,"/%s/%s",streama.c_str(),obj->GetName());
+                    Scatter2D* dps = new Scatter2D(a);
+
+                    TH1* HH= (TH1*)(obj);
+
+                    for (int i = 1; i <= HH->GetNbinsX(); ++i)
+                        {
+                            const double x = HH->GetBinCenter(i);
+                            const double exminus = x - HH->GetBinLowEdge(i);
+                            const double explus = HH->GetBinLowEdge(i+1) - x;
+                            const double width = exminus + explus;
+                            dps->addPoint(x, HH->GetBinContent(i),
+                                          exminus, explus,
+                                          HH->GetBinErrorLow(i), HH->GetBinErrorUp(i));
+                        }
+                    dps->setAnnotation("Title", obj->GetTitle());
+                    dps->setAnnotation("XLabel", HH->GetXaxis()->GetTitle());
+                    dps->setAnnotation("YLabel", HH->GetYaxis()->GetTitle());
+                    aos.push_back(dps);
+#else
+                    char a[255];
+                    sprintf(a,"/%s/%s",streama.c_str(),obj->GetName());
+                    YODA::Histo1D* dps = new YODA::Histo1D(a);//_histo1d.bins, _histo1d.dbn_tot, _histo1d.dbn_uflow, _histo1d.dbn_oflow);
+                    int i;
+
+                    if (type==11)
+                        {
+                            TH1F* HHF= (TH1F*)(obj);
+                            if (HHF->GetNbinsX()>0)
+                                {
+                                    for (i=1; i<HHF->GetNbinsX(); i++)
+                                        dps->addBin(HHF->GetBinLowEdge(i),HHF->GetBinLowEdge(i)+ HHF->GetBinWidth(i));
+                                    dps->setAnnotation("Title", obj->GetTitle());
+                                    dps->setAnnotation("TitleX", HHF->GetXaxis()->GetTitle());
+                                    dps->setAnnotation("TitleY", HHF->GetYaxis()->GetTitle());
+                                    for (i=1; i<HHF->GetNbinsX(); i++) dps->fill(HHF->GetBinCenter(i), HHF->GetBinContent(i));
+                                }
+                            aos.push_back(dps);
+                        }
+
+                    if (type==12)
+                        {
+                            TH1D* HHD= (TH1D*)(obj);
+                            if (HHD->GetNbinsX()>0)
+                                {
+                                    for (i=1; i<HHD->GetNbinsX(); i++)
+                                        dps->addBin(HHD->GetBinLowEdge(i),HHD->GetBinLowEdge(i)+ HHD->GetBinWidth(i));
+                                    dps->setAnnotation("Title", obj->GetTitle());
+                                    dps->setAnnotation("TitleX", HHD->GetXaxis()->GetTitle());
+                                    dps->setAnnotation("TitleY", HHD->GetYaxis()->GetTitle());
+                                    for (i=1; i<HHD->GetNbinsX(); i++) dps->fill(HHD->GetBinCenter(i), HHD->GetBinContent(i));
+                                }
+                            aos.push_back(dps);
+                        }
+
+
+#endif
+                    cleanup();
+                }
+            if (type==2)   printf("<W> Object %s has unsupported type TH2\n",obj->GetName()) ;
+            if (type==31||type==32||type==33)
+                {
+                    char a[255];
+                    sprintf(a,"/%s/%s",streama.c_str(),obj->GetName());
+                    Scatter2D* dps = new Scatter2D(a);
+                    int i;
+                    TGraphAsymmErrors* HH=(TGraphAsymmErrors*)obj;
+
+                    for (i=0; i<HH->GetN()-1; i++)
+                        {
+                            double x,y;
+                            HH->GetPoint(i,x,y);
+                            dps->addPoint(x, y,
+                                          HH->GetErrorXlow(i),
+                                          HH->GetErrorXhigh(i),
+                                          HH->GetErrorYlow(i),
+                                          HH->GetErrorYhigh(i)
+                                         );
+                        }
+                    dps->setAnnotation("Title", obj->GetTitle());
+                    dps->setAnnotation("TitleX", HH->GetXaxis()->GetTitle());
+                    dps->setAnnotation("TitleY", HH->GetYaxis()->GetTitle());
+                    aos.push_back(dps);
+                    cleanup();
+                }
+
+
+
+        }
+    fin->Close();
+}
+
+
+
+
+}
