diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./bin/Makefile.am ./bin/Makefile.am
--- ./bin/Makefile.am	2014-12-02 19:07:51.105628580 +0100
+++ ./bin/Makefile.am	2014-12-02 19:07:51.109628544 +0100
@@ -17,3 +17,18 @@
       $(install_sh_DATA) yoda-completion $(bashcomp_dir)/; fi
 uninstall-local:
 	rm -f $(bashcomp_dir)/yoda-completion
+
+#bin_PROGRAMS = yodaconvert
+#yodaconvert_OBJECTS = yodaconvert.o
+#yodaconvert_DEPENDENCIES =
+#yodaconvert_SOURCES = yodaconvert.cc
+#yodaconvert_CXXFLAGS=-std=c++0x -I../include
+#yodaconvert_LDADD= $(SUBLIBS) $(AM_LDFLAGS) $(top_builddir)/src/libYODA.la 
+
+#if  ENABLE_ROOT
+#if ENABLE_PYEXT
+#dist_bin_SCRIPTS += yoda2root
+#endif
+#yodaconvert_LDADD= $(SUBLIBS) $(AM_LDFLAGS) ../src/libYODA.la $(ROOT_LIBS)
+#yodaconvert_CXXFLAGS= -std=c++0x -I../include $(ROOT_CXXFLAGS) -Wno-long-long  -DENABLE_ROOT
+#endif
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./include/YODA/ReaderROOT.h ./include/YODA/ReaderROOT.h
--- ./include/YODA/ReaderROOT.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/YODA/ReaderROOT.h	2014-12-02 19:07:51.117628472 +0100
@@ -0,0 +1,75 @@
+// -*- C++ -*-
+//
+// This file is part of YODA -- Yet more Objects for Data Analysis
+//Andrii Verbytskyi, 2014
+//
+#ifndef YODA_READERROOT_H
+#define YODA_READERROOT_H
+
+#include "YODA/AnalysisObject.h"
+#include "YODA/Reader.h"
+#include "YODA/ROOTConvert.h"
+#include <YODA/Scatter2D.h>
+#include <boost/spirit/include/qi.hpp>
+#include <boost/spirit/include/phoenix_operator.hpp>
+#include <boost/fusion/include/adapt_struct.hpp>
+
+
+namespace YODA {
+
+  using namespace boost::spirit;
+  using namespace boost::phoenix;
+
+
+  /// Persistency reader from YODA flat text data format.
+  class ReaderROOT : public Reader {
+  public:
+
+    /// Singleton creation function
+    static Reader& create() {
+      static ReaderROOT _instance;
+      return _instance;
+    }
+
+    static Reader& create(std::string filename) {
+      static ReaderROOT _instance(filename);      
+      return _instance;
+    }
+
+
+    void read(std::istream& stream, std::vector<AnalysisObject*>& aos) {
+      _readDoc(stream, aos);
+    }
+
+
+
+    // Hide from Doxygen until endcond
+    /// @cond
+
+
+  protected:
+
+    void _readDoc(std::istream& stream, std::vector<AnalysisObject*>& aos);
+
+
+  private:
+std::string _filename;
+
+
+  public:
+
+    /// Private constructor, since it's a singleton.
+    /// @todo This is definitely not private!
+
+    ReaderROOT() { }
+    ReaderROOT(std::string filename) {_filename=filename;}
+
+  
+};
+
+} // end of YODA namespace
+
+
+/// @endcond
+
+#endif
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./include/YODA/ROOTCnv.h ./include/YODA/ROOTCnv.h
--- ./include/YODA/ROOTCnv.h	2014-12-02 19:07:51.093628690 +0100
+++ ./include/YODA/ROOTCnv.h	2014-12-02 19:07:51.117628472 +0100
@@ -15,6 +15,11 @@
 #include "TProfile.h"
 #include "TGraphAsymmErrors.h"
 #include "TVectorF.h"
+#include "TFile.h"
+#include "TList.h"
+#include "TKey.h"
+#include "TClass.h"
+#include "TH1F.h"
 
 namespace YODA {
 
@@ -33,27 +38,27 @@
   // ///
   // /// Note that ROOT's histograms do not contain enough information to properly rebuild
   // /// @a x distributions within bins, in underflow and overflow bins, or across the whole histogram.
-  // inline Histo1D toHisto1D(const TH1& th1) {
-  //   std::vector<HistoBin1D> bins;
-  //   TArrayD sumw2s = *th1.GetSumw2();
-  //   Dbn1D dbn_uflow, dbn_oflow;
-  //   double sumWtot(0), sumW2tot(0)
-  //   for (int i = 0; i =< th1.GetNbinsX()+1; ++i) {
-  //     Dbn1D dbn(static_cast<unsigned long>(th1.GetBinContent(i)), th1.GetBinContent(i), sumw2s[i], 0, 0);
-  //               // th1.GetBinContent(i)*th1.GetBinCenter(i), th1.GetBinContent(i)*sqr(th1.GetBinCenter(i)));
-  //     if (i == 0) dbn_uflow = dbn;
-  //     else if (i == th1.GetNbinsX()+1) dbn_oflow = dbn;
-  //     else bins.push_back(HistoBin1D(std::make_pair(th1.GetBinLowEdge(i), th1.GetBinLowEdge(i+1)), dbn));
-  //     sumWtot += th1.GetBinContent(i);
-  //     sumW2tot += sumw2s[i];
-  //   }
-  //   Dbn1D dbn_tot(static_cast<unsigned long>(th1.GetEntries()), sumWtot, sumW2tot, 0, 0);
-
-  //   Histo1D rtn(bins, dbn_tot, dbn_uflow, const Dbn1D& dbn_oflow, th1.GetName(), th1.GetTitle());
-  //   rtn.addAnnotation("XLabel", th1.GetXaxis->GetTitle());
-  //   rtn.addAnnotation("YLabel", th1.GetYaxis->GetTitle());
-  //   return rtn;
-  // }
+inline Histo1D toHisto1D(const TH1& th1) {
+   std::vector<HistoBin1D> bins;
+   TArrayD sumw2s = *th1.GetSumw2();
+    Dbn1D dbn_uflow, dbn_oflow;
+     double sumWtot(0), sumW2tot(0)
+    for (int i = 0; i =< th1.GetNbinsX()+1; ++i) {
+      Dbn1D dbn(static_cast<unsigned long>(th1.GetBinContent(i)), th1.GetBinContent(i), sumw2s[i], 0, 0,
+                  th1.GetBinContent(i)*th1.GetBinCenter(i), th1.GetBinContent(i)*sqr(th1.GetBinCenter(i)));
+       if (i == 0) dbn_uflow = dbn;
+      else if (i == th1.GetNbinsX()+1) dbn_oflow = dbn;
+       else bins.push_back(HistoBin1D(std::make_pair(th1.GetBinLowEdge(i), th1.GetBinLowEdge(i+1)), dbn));
+     sumWtot += th1.GetBinContent(i);
+      sumW2tot += sumw2s[i];
+     }
+    Dbn1D dbn_tot(static_cast<unsigned long>(th1.GetEntries()), sumWtot, sumW2tot, 0, 0);
+
+    Histo1D rtn(bins, dbn_tot, dbn_uflow, const Dbn1D& dbn_oflow, th1.GetName(), th1.GetTitle());
+    rtn.addAnnotation("XLabel", th1.GetXaxis->GetTitle());
+    rtn.addAnnotation("YLabel", th1.GetYaxis->GetTitle());
+    return rtn;
+  }
 
 
   // /// @brief Convert a ROOT 1D histogram to a YODA Histo1D
@@ -72,7 +77,7 @@
   ///
   /// @todo Add a bool flag for whether or not to divide y vals/errs by bin width.
   inline Scatter2D toScatter2D(const TH1& th1) {
-    Scatter2D rtn;
+    Scatter2D rtn; 
     for (int i = 1; i <= th1.GetNbinsX(); ++i) {
       const double x = th1.GetBinCenter(i);
       const double exminus = x - th1.GetBinLowEdge(i);
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./include/YODA/ROOTConvert.h ./include/YODA/ROOTConvert.h
--- ./include/YODA/ROOTConvert.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/YODA/ROOTConvert.h	2014-12-02 19:07:51.114628499 +0100
@@ -0,0 +1,44 @@
+// -*- C++ -*-
+//
+// This file is part of YODA -- Yet more Objects for Data Analysis
+// Copyright (C) 2008-2013 The YODA collaboration (see AUTHORS for details)
+//
+#ifndef YODA_ROOTCnv_h
+#define YODA_ROOTCnv_h
+
+#include "YODA/Histo1D.h"
+#include "YODA/Histo2D.h"
+#include "YODA/Profile1D.h"
+#include "YODA/Histo1D.h"
+#include "YODA/Profile1D.h"
+#include "YODA/Scatter2D.h"
+#include "TH1.h"
+#include "TH2.h"
+#include "TProfile.h"
+#include "TGraphAsymmErrors.h"
+#include "TVectorF.h"
+#include "TFile.h"
+#include "TList.h"
+#include "TKey.h"
+#include "TClass.h"
+#include "TH1F.h"
+#include <string>
+
+namespace YODA {
+//Scatter2D*         TH1toScatter2D(const TH1* th1) ;
+
+
+
+
+Histo1D*           TH1toHisto1D  (const TH1* th1, std::string fname="");
+TH1D*              Histo1DtoTH1D(const Histo1D* h) ;
+
+Profile1D*         TProfiletoProfile1D(const TProfile*  p, std::string fname="") ;
+TProfile*          Profile1DtoTProfile(const Profile1D* p) ;
+
+Scatter2D*         TGraphtoScatter2D(const TGraph* g, std::string fname="") ;
+TGraphAsymmErrors* Scatter2DtoTGraphAsymmErrors(const Scatter2D* s) ;
+
+}
+
+#endif
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./include/YODA/WriterROOT.h ./include/YODA/WriterROOT.h
--- ./include/YODA/WriterROOT.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/YODA/WriterROOT.h	2014-12-02 19:07:51.114628499 +0100
@@ -0,0 +1,72 @@
+// -*- C++ -*-
+//
+// This file is part of YODA -- Yet more Objects for Data Analysis
+// Copyright (C) 2008-2013 The YODA collaboration (see AUTHORS for details)
+//
+#ifndef YODA_WRITERROOT_H
+#define YODA_WRITERROOT_H
+
+#include "YODA/AnalysisObject.h"
+#include "YODA/Writer.h"
+#include "YODA/ROOTConvert.h"
+#include <vector>
+#include <string>
+#include <ostream>
+
+
+namespace YODA {
+
+
+  /// Persistency writer for flat text format.
+  class WriterROOT : public Writer {
+  public:
+
+    /// Singleton creation function
+    static Writer& create() {
+      static WriterROOT _instance;
+      _instance.setPrecision(6);
+      return _instance;
+    }
+
+    static Writer& create(std::string filename) {
+      static WriterROOT _instance(filename);
+      _instance.setPrecision(6);
+      return _instance;
+    }
+
+
+    // Include definitions of all write methods (all fulfilled by Writer::write(...))
+    #include "YODA/WriterMethods.icc"
+
+
+  protected:
+
+    void writeHeader(std::ostream& stream);
+    //void writeBody(std::ostream& stream, const AnalysisObject& ao);
+    void writeFooter(std::ostream& stream);
+  //void write(const std::string& filename, const AnalysisObject& ao);
+    void writeCounter(std::ostream& stream, const Counter& c);
+    void writeHisto1D(std::ostream& stream, const Histo1D& h);
+    void writeHisto2D(std::ostream& stream, const Histo2D& h);
+    void writeProfile1D(std::ostream& stream, const Profile1D& p);
+     void writeProfile2D(std::ostream& stream, const Profile2D& p);
+    void writeScatter1D(std::ostream& stream, const Scatter1D& s);
+    void writeScatter2D(std::ostream& stream, const Scatter2D& s);
+     void writeScatter3D(std::ostream& stream, const Scatter3D& s);
+
+
+  private:
+std::string _filename;
+TFile* _ROOTfile;
+    void _writeAnnotations(std::ostream& os, const AnalysisObject& ao);
+
+    /// Private since it's a singleton.
+    WriterROOT() { }
+    WriterROOT(std::string filename) {  _filename=filename; _ROOTfile=new TFile(filename.c_str(),"recreate");  }
+     ~WriterROOT() {if (_ROOTfile) _ROOTfile->Close();}
+  };
+
+
+}
+
+#endif
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./Makefile.am ./Makefile.am
--- ./Makefile.am	2014-12-02 19:07:51.084628771 +0100
+++ ./Makefile.am	2014-12-02 19:07:51.118628462 +0100
@@ -1,8 +1,8 @@
 ACLOCAL_AMFLAGS = -I m4
 
-SUBDIRS = src include tests bin
+SUBDIRS = src include  tests bin
 if ENABLE_PYEXT
-SUBDIRS += pyext
+SUBDIRS+=pyext
 endif
 
 EXTRA_FILES = main.dox
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./pyext/Makefile.am ./pyext/Makefile.am
--- ./pyext/Makefile.am	2014-12-02 19:07:51.096628663 +0100
+++ ./pyext/Makefile.am	2014-12-02 19:07:51.118628462 +0100
@@ -4,7 +4,7 @@
 PYEXT_ENV = CC="$(CC)" CXX="$(CXX)" CXXFLAGS="$(PYEXT_CXXFLAGS)" ARCHFLAGS=""
 
 if ENABLE_ROOT
-  PYEXT_ENV += BUILD_ROOTCOMPAT="yes"
+  PYEXT_ENV = CC="$(CXX)" CXX="$(CXX)" CXXFLAGS="$(PYEXT_CXXFLAGS) $(ROOT_CXXFLAGS) -Wno-long-long  -DENABLE_ROOT" CFLAGS="$(PYEXT_CFLAGS) $(ROOT_CXXFLAGS) -Wno-long-long  -DENABLE_ROOT" ARCHFLAGS="" BUILD_ROOTCOMPAT="yes"
 endif
 
 ## Always force setup.py, it's not good at guessing what needs to rebuild
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./pyext/yoda/declarations.pxd ./pyext/yoda/declarations.pxd
--- ./pyext/yoda/declarations.pxd	2014-12-02 19:07:51.100628627 +0100
+++ ./pyext/yoda/declarations.pxd	2014-12-02 19:07:51.125628398 +0100
@@ -251,7 +251,7 @@
         Point2D () except +yodaerr
         Point2D (Point2D p) except +yodaerr
         Point2D (double x, double y,
-                 double exminus, double explus,
+                  double exminus, double explus,
                  double eyminus, double eyplus) except +yodaerr
 
         double x() except +yodaerr
@@ -720,7 +720,7 @@
         Scatter2D(string path, string title) except +yodaerr
 
         Scatter2D(sortedvector[Point2D],
-                  string path,
+                string path,
                   string title) except +yodaerr
 
         Scatter2D(vector[double], vector[double],
@@ -778,7 +778,7 @@
         Scatter3D(string path, string title) except +yodaerr
 
         Scatter3D(sortedvector[Point3D],
-                  string path,
+                string path,
                   string title) except +yodaerr
 
         Scatter3D(vector[double], vector[double],
@@ -1217,6 +1217,9 @@
 cdef extern from "YODA/ReaderFLAT.h" namespace "YODA":
     Reader& ReaderFLAT_create "YODA::ReaderFLAT::create" ()
 
+cdef extern from "YODA/ReaderROOT.h" namespace "YODA":
+    Reader& ReaderROOT_create "YODA::ReaderROOT::create" ()
+
 cdef extern from "YODA/ReaderAIDA.h" namespace "YODA":
     Reader& ReaderAIDA_create "YODA::ReaderAIDA::create" ()
 
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./pyext/yoda/Makefile.am ./pyext/yoda/Makefile.am
--- ./pyext/yoda/Makefile.am	2014-12-02 19:07:51.097628654 +0100
+++ ./pyext/yoda/Makefile.am	2014-12-02 19:07:51.120628443 +0100
@@ -46,6 +46,10 @@
     mktemplates \
     core.cpp core.h util.cpp
 
+if ENABLE_ROOT
+  CXXFLAGS += $(ROOT_CXXFLAGS) -Wno-long-long 
+endif
+
 
 if WITH_CYTHON
 core.cpp core.h: $(CYTHON_SRC)
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./pyext/yoda/mktemplates ./pyext/yoda/mktemplates
--- ./pyext/yoda/mktemplates	2014-12-02 19:07:51.100628627 +0100
+++ ./pyext/yoda/mktemplates	2014-12-02 19:07:51.125628398 +0100
@@ -50,9 +50,9 @@
     #print plain_name
 
     try:
-        os.mkdir("generated")
+        os.mkdir("include/generated")
     except OSError as exc: # Python >2.5
-        if exc.errno == errno.EEXIST and os.path.isdir("generated"):
+        if exc.errno == errno.EEXIST and os.path.isdir("include/generated"):
             pass
         else: raise
 
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./pyext/yoda/rootcompat.pxd ./pyext/yoda/rootcompat.pxd
--- ./pyext/yoda/rootcompat.pxd	2014-12-02 19:07:51.097628654 +0100
+++ ./pyext/yoda/rootcompat.pxd	2014-12-02 19:07:51.120628443 +0100
@@ -28,8 +28,8 @@
 cdef extern from "pyroot_helpers.hh":
     cpython.PyObject* root_to_py_owned(TObject* root_obj)
 
-cdef extern from "YODA/ROOTCnv.h" namespace "YODA":
-    Scatter2D toScatter2D(TH1*)
-    TH1D toTH1D(Histo1D)
-    TProfile toTProfile(Profile1D)
-    TGraphAsymmErrors toTGraph(Scatter2D)
+#cdef extern from "YODA/ROOTCnv.h" namespace "YODA":
+#    Scatter2D toScatter2D(TH1*)
+#    TH1D toTH1D(Histo1D)
+#    TProfile toTProfile(Profile1D)
+#    TGraphAsymmErrors toTGraph(Scatter2D)
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./pyext/yoda/rootcompat.pyx ./pyext/yoda/rootcompat.pyx
--- ./pyext/yoda/rootcompat.pyx	2014-12-02 19:07:51.100628627 +0100
+++ ./pyext/yoda/rootcompat.pyx	2014-12-02 19:07:51.126628389 +0100
@@ -24,26 +24,27 @@
 
     cdef void *ptr = yoda_obj.ptr()
 
-    if isinstance(yoda_obj, yoda.Histo1D):
-        return _toTH1D(<cyoda.Histo1D*> ptr)
+    return <object> ptr
+#    if isinstance(yoda_obj, yoda.Histo1D):
+#        return _toTH1D(<cyoda.Histo1D*> ptr)
 
-    elif isinstance(yoda_obj, yoda.Profile1D):
-        return _toTProfile(<cyoda.Profile1D*> ptr)
+#    elif isinstance(yoda_obj, yoda.Profile1D):
+#        return _toTProfile(<cyoda.Profile1D*> ptr)
 
-    elif isinstance(yoda_obj, yoda.Scatter2D):
-        return _toTGraph(<cyoda.Scatter2D*> ptr)
+#    elif isinstance(yoda_obj, yoda.Scatter2D):
+#        return _toTGraph(<cyoda.Scatter2D*> ptr)
 
 cdef object root_to_py(c.TObject* tobj):
     return <object> c.root_to_py_owned(tobj)
 
-cdef _toTH1D(cyoda.Histo1D* h1d):
-    return ROOT.TH1D(
-        root_to_py(new c.TH1D(c.toTH1D(deref(h1d)))))
-
-cdef _toTProfile(cyoda.Profile1D* p1d):
-    return ROOT.TProfile(
-        root_to_py(new c.TProfile(c.toTProfile(deref(p1d)))))
-
-cdef _toTGraph(cyoda.Scatter2D* s2d):
-    return ROOT.TGraphAsymmErrors(
-        root_to_py(new c.TGraphAsymmErrors(c.toTGraph(deref(s2d)))))
+#cdef _toTH1D(cyoda.Histo1D* h1d):
+#    return ROOT.TH1D(
+#        root_to_py(new c.TH1D(c.toTH1D(deref(h1d)))))
+
+#cdef _toTProfile(cyoda.Profile1D* p1d):
+#    return ROOT.TProfile(
+#        root_to_py(new c.TProfile(c.toTProfile(deref(p1d)))))
+
+#cdef _toTGraph(cyoda.Scatter2D* s2d):
+#    return ROOT.TGraphAsymmErrors(
+#        root_to_py(new c.TGraphAsymmErrors(c.toTGraph(deref(s2d)))))
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./src/Makefile.am ./src/Makefile.am
--- ./src/Makefile.am	2014-12-02 19:07:51.102628607 +0100
+++ ./src/Makefile.am	2014-12-02 19:07:51.126628389 +0100
@@ -13,7 +13,7 @@
     WriterAIDA.cc \
     WriterFLAT.cc \
     Dbn0D.cc \
-	Dbn1D.cc \
+    Dbn1D.cc \
     Counter.cc \
     Histo1D.cc \
     Histo2D.cc \
@@ -24,6 +24,14 @@
     Scatter3D.cc
 
 
-libYODA_la_LDFLAGS = -avoid-version
+libYODA_la_LDFLAGS = -avoid-version 
 libYODA_la_LIBADD = tinyxml/libtinyxml.la
-libYODA_la_CPPFLAGS = $(AM_CPPFLAGS) -DTIXML_USE_STL
+libYODA_la_CPPFLAGS = $(AM_CPPFLAGS) -DTIXML_USE_STL 
+
+if  ENABLE_ROOT
+libYODA_la_SOURCES += ROOTConvert.cc 
+libYODA_la_SOURCES += ReaderROOT.cc 
+libYODA_la_SOURCES += WriterROOT.cc 
+libYODA_la_LDFLAGS += $(ROOT_LDFLAGS)
+libYODA_la_CPPFLAGS += $(ROOT_CXXFLAGS) -Wno-long-long 
+endif
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./src/Reader.cc ./src/Reader.cc
--- ./src/Reader.cc	2014-12-02 19:07:51.103628598 +0100
+++ ./src/Reader.cc	2014-12-02 19:07:51.128628371 +0100
@@ -5,6 +5,9 @@
 //
 #include "YODA/Reader.h"
 #include "YODA/ReaderYODA.h"
+#ifdef ENABLE_ROOT
+#include "YODA/ReaderROOT.h"
+#endif
 #include "YODA/ReaderAIDA.h"
 #include "YODA/ReaderFLAT.h"
 
@@ -20,8 +23,11 @@
     if (fmt == "yoda") return ReaderYODA::create();
     if (fmt == "aida") return ReaderAIDA::create();
     if (fmt == "dat" || fmt == "flat")  return ReaderFLAT::create();
+#ifdef ENABLE_ROOT
+    if (fmt == "root") return ReaderROOT::create(name);
+#endif
     throw UserError("Format cannot be identified from string '" + name + "'");
-  }
+}
 
 
 }
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./src/ReaderROOT.cc ./src/ReaderROOT.cc
--- ./src/ReaderROOT.cc	1970-01-01 01:00:00.000000000 +0100
+++ ./src/ReaderROOT.cc	2014-12-02 19:07:51.126628389 +0100
@@ -0,0 +1,85 @@
+// -*- C++ -*-
+//
+// This file is part of YODA -- Yet more Objects for Data Analysis
+// Copyright (C) 2008-2013 The YODA collaboration (see AUTHORS for details)
+//
+
+#include "YODA/ReaderROOT.h"
+#include "YODA/Utils/StringUtils.h"
+#include "YODA/Exceptions.h"
+#include <iostream>
+
+
+
+using namespace std;
+
+namespace YODA
+{
+
+void ReaderROOT::_readDoc(std::istream& stream, vector<AnalysisObject*>& aos)
+{
+    std::string streama=_filename; //Ugly trick;
+    TFile* fin = new TFile(streama.c_str()) ;
+    if (!fin->IsOpen())
+        {
+            printf("Cannot open input file %s\n",streama.c_str()) ;
+            exit(1) ;
+        }
+
+    TList* list = fin->GetListOfKeys() ;
+    if (!list) { printf("No keys found in file %s\n",streama.c_str()) ; exit(1) ; }
+
+    TIter next(list) ;
+    TKey* key ;
+    TObject* obj ;
+
+    while ( key = (TKey*)next() )
+        {
+            obj = key->ReadObj() ;
+            int type=-1;
+
+            if (strcmp(obj->IsA()->GetName(),"TProfile")==0) type=0;
+            if (strcmp(obj->IsA()->GetName(),"TH1F")==0)type=11;
+            if (strcmp(obj->IsA()->GetName(),"TH1D")==0) type=12;
+            if (obj->InheritsFrom("TH2")) type=2;
+            if (strcmp(obj->IsA()->GetName(),"TGraph")==0)type=31;
+            if (strcmp(obj->IsA()->GetName(),"TGraphErrors")==0) type=32;
+            if (strcmp(obj->IsA()->GetName(),"TGraphAsymmErrors")==0)type=33;
+            if (type==-1)  printf("Object %s  has unsupported type %s and will not be converted\n",obj->GetName(),obj->IsA()->GetName()) ;
+            if (type==0)
+                {
+                    TProfile* P= (TProfile*)(obj);
+                    YODA::Profile1D* dps = TProfiletoProfile1D(P,_filename);
+                    aos.push_back(dps);
+                }
+            if (type==11||type==12)
+                {
+                    /*
+                    The mapping is TH? <-> Histo?D, TProfile <-> Profile1D, TGraph <-> Scatter2D.
+                    */
+
+                    if (type==11)
+                        {
+                            TH1F* HHF= (TH1F*)(obj);
+                            YODA::Histo1D* dps=YODA::TH1toHisto1D(HHF,_filename);
+                            aos.push_back(dps);
+                        }
+                    if (type==12)
+                        {
+                            TH1D* HHD= (TH1D*)(obj);
+                            YODA::Histo1D* dps=YODA::TH1toHisto1D(HHD);
+                            aos.push_back(dps);
+                        }
+                }
+            if (type==2)   printf("<W> Object %s has unsupported type TH2\n",obj->GetName()) ;
+            if (type==31||type==32||type==33)
+                {
+                    TGraphAsymmErrors* G=(TGraphAsymmErrors*)obj;
+                    Scatter2D* dps = YODA::TGraphtoScatter2D(G,_filename);
+                    aos.push_back(dps);
+                }
+        }
+    fin->Close();
+}
+
+}
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./src/ROOTConvert.cc ./src/ROOTConvert.cc
--- ./src/ROOTConvert.cc	1970-01-01 01:00:00.000000000 +0100
+++ ./src/ROOTConvert.cc	2014-12-02 19:07:51.126628389 +0100
@@ -0,0 +1,233 @@
+// -*- C++ -*-
+//
+// This file is part of YODA -- Yet more Objects for Data Analysis
+// Copyright (C) 2008-2013 The YODA collaboration (see AUTHORS for details)
+//
+#ifndef YODA_ROOTCnv_h
+#define YODA_ROOTCnv_h
+
+#include "YODA/ROOTConvert.h"
+#include "YODA/Histo1D.h"
+#include "YODA/Histo2D.h"
+#include "YODA/Histo1D.h"
+#include "YODA/Profile1D.h"
+#include "YODA/Scatter2D.h"
+
+#include "TH1.h"
+#include "TH2.h"
+#include "TProfile.h"
+#include "TGraphAsymmErrors.h"
+#include "TVectorF.h"
+#include "TFile.h"
+#include "TList.h"
+#include "TKey.h"
+#include "TClass.h"
+#include "TH1F.h"
+#include <string>
+
+namespace YODA
+{
+
+Histo1D* TH1toHisto1D(const TH1* th1, std::string fname)
+{
+    std::vector<HistoBin1D> bins;
+    const TArrayD* sumw2s = th1->GetSumw2();
+    Dbn1D dbn_uflow, dbn_oflow;
+    double sumWtot=0, sumW2tot=0;
+    for (int i = 0; i <= th1->GetNbinsX()+1; ++i)
+        {
+            Dbn1D dbn(static_cast<unsigned long>(th1->GetBinContent(i)), th1->GetBinContent(i), sumw2s->GetAt(i) 
+                      , 0, 0);
+            //th1->GetBinContent(i)*th1->GetBinCenter(i), th1->GetBinContent(i)*sqr(th1->GetBinCenter(i)));
+            if (i == 0) dbn_uflow = dbn;
+            else if (i == th1->GetNbinsX()+1) dbn_oflow = dbn;
+            else bins.push_back(HistoBin1D(std::make_pair(th1->GetBinLowEdge(i), th1->GetBinLowEdge(i+1)), dbn));
+            sumWtot += th1->GetBinContent(i);
+            sumW2tot +=   sumw2s->GetAt(i);
+        }
+    Dbn1D dbn_tot(static_cast<unsigned long>(th1->GetEntries()), sumWtot, sumW2tot, 0, 0);
+
+    Histo1D* rtn =new Histo1D(bins, dbn_tot, dbn_uflow, dbn_oflow,std::string("/")+fname+std::string("/")+th1->GetName(), th1->GetTitle());
+    rtn->setAnnotation("XLabel", th1->GetXaxis()->GetTitle());
+    rtn->setAnnotation("YLabel", th1->GetYaxis()->GetTitle());
+    rtn->setAnnotation("Title", std::string("/")+th1->GetTitle());
+    return rtn;
+}
+
+Scatter2D* TH1toScatter2D(const TH1* th1, std::string fname)
+{
+    Scatter2D* rtn = new Scatter2D(std::string("/")+fname+std::string("/")+th1->GetName());
+    for (int i = 1; i <= th1->GetNbinsX(); ++i)
+        {
+            const double x = th1->GetBinCenter(i);
+            const double exminus = x - th1->GetBinLowEdge(i);
+            const double explus = th1->GetBinLowEdge(i+1) - x;
+            const double width = exminus + explus;
+            rtn->addPoint(x, th1->GetBinContent(i)/width,
+                          exminus, explus,
+                          th1->GetBinErrorLow(i)/width, th1->GetBinErrorUp(i)/width);
+        }
+    rtn->setAnnotation("XLabel", th1->GetXaxis()->GetTitle());
+    rtn->setAnnotation("YLabel", th1->GetYaxis()->GetTitle());
+    rtn->setAnnotation("Title", std::string("/")+th1->GetTitle());
+    return rtn;
+}
+
+
+
+
+Profile1D*         TProfiletoProfile1D(const TProfile* p, std::string fname)
+{
+
+
+    Profile1D* rtn = new Profile1D(std::string("/")+fname+std::string("/")+p->GetName());
+    for (int i = 1; i <= p->GetNbinsX(); ++i)
+        {
+            const double x = p->GetBinCenter(i);
+            const double exminus = x - p->GetBinLowEdge(i);
+            const double explus = p->GetBinLowEdge(i+1) - x;
+            const double width = exminus + explus;
+//FIXME      rtn->addPoint(x, p->GetBinContent(i)/width, exminus, explus,  p->GetBinErrorLow(i)/width, p->GetBinErrorUp(i)/width);
+        }
+    rtn->setAnnotation("XLabel", p->GetXaxis()->GetTitle());
+    rtn->setAnnotation("YLabel", p->GetYaxis()->GetTitle());
+    rtn->setAnnotation("Title", std::string("/")+p->GetTitle());
+    return rtn;
+
+}
+
+
+Scatter2D* TGraphtoScatter2D(const TGraph* g, std::string fname)
+{
+    Scatter2D* rtn = new Scatter2D(std::string("/")+fname+std::string("/")+g->GetName());
+    int i;
+    for (i=0; i<g->GetN()-1; i++)
+        {
+            double x,y;
+            g->GetPoint(i,x,y);
+            rtn->addPoint(x, y,
+                          g->GetErrorXlow(i),
+                          g->GetErrorXhigh(i),
+                          g->GetErrorYlow(i),
+                          g->GetErrorYhigh(i)
+                         );
+        }
+    rtn->addAnnotation("XLabel", g->GetXaxis()->GetTitle());
+    rtn->addAnnotation("YLabel", g->GetYaxis()->GetTitle());
+    rtn->setAnnotation("Title", std::string("/")+g->GetTitle());
+    return rtn;
+}
+
+
+
+TH1D* Histo1DtoTH1D(const Histo1D* h)
+{
+    // Work out bin edges first
+    std::vector<double> edges;
+    edges.reserve(h->numBins()+1);
+    edges.push_back(h->bin(0).xMin());
+    for (size_t i = 0; i < h->numBins(); ++i)
+        {
+            const HistoBin1D& b = h->bin(i);
+            if (!fuzzyEquals(edges.back(), b.xMin())) edges.push_back(b.xMin());
+            if (!fuzzyEquals(edges.back(), b.xMax())) edges.push_back(b.xMax());
+        }
+    // Book ROOT histogram
+    TH1D* rtn= new TH1D(h->path().c_str(), h->title().c_str(), edges.size()-1, &edges[0]);
+    rtn->Sumw2();
+    TArrayD* sumw2s = new TArrayD(*(rtn->GetSumw2()));
+    for (int i = 1; i <= rtn->GetNbinsX(); ++i)
+        {
+            try
+                {
+                    const HistoBin1D& b = h->binAt(rtn->GetBinCenter(i)); // throws if in a gap
+                    rtn->SetBinContent(i, b.sumW());
+                    //FIXME sumw2s[i] = b.sumW2();
+                }
+            catch (const Exception& e) {  }
+        }
+    // Overflows
+    rtn->SetBinContent(0, h->underflow().sumW());
+    rtn->SetBinContent(rtn->GetNbinsX()+1, h->overflow().sumW());
+    //FIXME  sumw2s[0] = h->underflow().sumW2();
+    //FIXME  sumw2s[rtn->GetNbinsX()+1] = h->overflow().sumW2();
+    // Labels
+    if (h->hasAnnotation("XLabel")) rtn->SetXTitle(h->annotation("XLabel").c_str());
+    if (h->hasAnnotation("YLabel")) rtn->SetYTitle(h->annotation("YLabel").c_str());
+
+    return rtn;
+}
+
+
+TProfile* Profile1DtoTProfile(const Profile1D* p)
+{
+    // Work out bin edges first
+    std::vector<double> edges;
+    edges.reserve(p->numBins()+1);
+    edges.push_back(p->bin(0).xMin());
+    for (size_t i = 0; i < p->numBins(); ++i)
+        {
+            const ProfileBin1D& b = p->bin(i);
+            if (!fuzzyEquals(edges.back(), b.xMin())) edges.push_back(b.xMin());
+            if (!fuzzyEquals(edges.back(), b.xMax())) edges.push_back(b.xMax());
+        }
+    // Book ROOT histogram
+    TProfile *rtn =new TProfile(p->path().c_str(), p->title().c_str(), edges.size()-1, &edges[0]);
+    rtn->Sumw2();
+    TArrayD* sumw2s = new TArrayD(*(rtn->GetSumw2()));
+    for (int i = 1; i <= rtn->GetNbinsX(); ++i)
+        {
+            try
+                {
+                    const ProfileBin1D& b = p->binAt(rtn->GetBinCenter(i)); // throws if in a gap
+                    /// @todo This part is probably wrong -- also need to do something with GetW,
+                    ///   GetW2, GetB, GetB2, and/or GetBinSumw2? ROOT docs are 100% useless...
+                    rtn->SetBinContent(i, b.sumW());
+                    //FIXME  sumw2s[i] = b.sumW2();
+                }
+            catch (const Exception& e) {  }
+        }
+    // Overflows
+    rtn->SetBinContent(0, p->underflow().sumW());
+    rtn->SetBinContent(rtn->GetNbinsX()+1, p->overflow().sumW());
+    //FIXME  sumw2s[0] = p->underflow().sumW2();
+    //FIXME  sumw2s[rtn->GetNbinsX()+1] = p->overflow().sumW2();
+    // Labels
+    if (p->hasAnnotation("XLabel")) rtn->SetXTitle(p->annotation("XLabel").c_str());
+    if (p->hasAnnotation("YLabel")) rtn->SetYTitle(p->annotation("YLabel").c_str());
+    return rtn;
+}
+
+
+
+TGraphAsymmErrors* Scatter2DtoTGraphAsymmErrors(const Scatter2D* s)
+{
+    TVectorF xs(s->numPoints()), ys(s->numPoints());
+    TVectorF exls(s->numPoints()), exhs(s->numPoints());
+    TVectorF eyls(s->numPoints()), eyhs(s->numPoints());
+    for (size_t i = 0; i < s->numPoints(); ++i)
+        {
+            const Point2D& p = s->point(i);
+            xs[i] = p.x();
+            ys[i] = p.y();
+            exls[i] = p.xErrMinus();
+            exhs[i] = p.xErrPlus();
+            eyls[i] = p.yErrMinus();
+            eyhs[i] = p.yErrPlus();
+        }
+    // Make the ROOT object... mm, the constructors don't take name+title, unlike all this histos!
+    TGraphAsymmErrors* rtn= new TGraphAsymmErrors(xs, ys, exls, exhs, eyls, eyhs);
+    rtn->SetName(s->path().c_str());
+    rtn->SetTitle(s->title().c_str());
+    // Labels
+    if (s->hasAnnotation("XLabel")) rtn->GetXaxis()->SetTitle(s->annotation("XLabel").c_str());
+    if (s->hasAnnotation("YLabel")) rtn->GetYaxis()->SetTitle(s->annotation("YLabel").c_str());
+    return rtn;
+}
+
+//@}
+
+
+}
+
+#endif
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./src/Writer.cc ./src/Writer.cc
--- ./src/Writer.cc	2014-12-02 19:07:51.102628607 +0100
+++ ./src/Writer.cc	2014-12-02 19:07:51.126628389 +0100
@@ -7,6 +7,9 @@
 #include "YODA/WriterYODA.h"
 #include "YODA/WriterAIDA.h"
 #include "YODA/WriterFLAT.h"
+#ifdef ENABLE_ROOT
+#include "YODA/WriterROOT.h"
+#endif
 #include "boost/algorithm/string.hpp"
 #include <iostream>
 #include <typeinfo>
@@ -23,16 +26,19 @@
     // cout << "File extension: " << fmt << endl;
     if (fmt == "yoda") return WriterYODA::create();
     if (fmt == "aida") return WriterAIDA::create();
-    if (fmt == "dat" || fmt == "flat") return WriterFLAT::create();
+    if (fmt == "flat") return WriterFLAT::create();
+#ifdef ENABLE_ROOT
+    if (fmt == "root") return WriterROOT::create(name);
+#endif
     throw UserError("Format cannot be identified from string '" + name + "'");
-  }
+}
 
 
   void Writer::write(std::ostream& stream, const AnalysisObject& ao) {
     writeHeader(stream);
     writeBody(stream, ao);
     writeFooter(stream);
-  }
+}
 
 
   void Writer::write(const std::string& filename, const AnalysisObject& ao) {
@@ -41,36 +47,36 @@
     outstream.open(filename.c_str());
     write(outstream, ao);
     outstream.close();
-  }
+}
 
 
   void Writer::writeBody(std::ostream& stream, const AnalysisObject& ao) {
     const string aotype = ao.type();
     if (aotype == "Counter") {
-      writeCounter(stream, dynamic_cast<const Counter&>(ao));
+            writeCounter(stream, dynamic_cast<const Counter&>(ao));
     } else if (aotype == "Histo1D") {
-      writeHisto1D(stream, dynamic_cast<const Histo1D&>(ao));
+            writeHisto1D(stream, dynamic_cast<const Histo1D&>(ao));
     } else if (aotype == "Histo2D") {
-      writeHisto2D(stream, dynamic_cast<const Histo2D&>(ao));
+            writeHisto2D(stream, dynamic_cast<const Histo2D&>(ao));
     } else if (aotype == "Profile1D") {
-      writeProfile1D(stream, dynamic_cast<const Profile1D&>(ao));
+            writeProfile1D(stream, dynamic_cast<const Profile1D&>(ao));
     } else if (aotype == "Profile2D") {
       writeProfile2D(stream, dynamic_cast<const Profile2D&>(ao));
     } else if (aotype == "Scatter1D") {
       writeScatter1D(stream, dynamic_cast<const Scatter1D&>(ao));
     } else if (aotype == "Scatter2D") {
-      writeScatter2D(stream, dynamic_cast<const Scatter2D&>(ao));
+            writeScatter2D(stream, dynamic_cast<const Scatter2D&>(ao));
     } else if (aotype == "Scatter3D") {
       writeScatter3D(stream, dynamic_cast<const Scatter3D&>(ao));
     } else if (aotype[0] == '_') {
       // skip writing AO types with underscore prefixes (needed e.g. for Rivet wrappers)
       // maybe write a comment line in the output
     } else {
-      ostringstream oss;
-      oss << "Unrecognised analysis object type " << aotype << " in Writer::write";
-      throw Exception(oss.str());
-    }
-  }
+            ostringstream oss;
+            oss << "Unrecognised analysis object type " << aotype << " in Writer::write";
+            throw Exception(oss.str());
+        }
+}
 
 
 }
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./src/WriterROOT.cc ./src/WriterROOT.cc
--- ./src/WriterROOT.cc	1970-01-01 01:00:00.000000000 +0100
+++ ./src/WriterROOT.cc	2014-12-02 19:07:51.126628389 +0100
@@ -0,0 +1,69 @@
+// -*- C++ -*-
+//
+// This file is part of YODA -- Yet more Objects for Data Analysis
+// Copyright (C) 2008-2013 The YODA collaboration (see AUTHORS for details)
+//
+#include "YODA/WriterROOT.h"
+
+#include "YODA/Histo1D.h"
+#include "YODA/Histo2D.h"
+#include "YODA/Profile1D.h"
+#include "YODA/Scatter2D.h"
+#include "YODA/ROOTConvert.h"
+#include <iostream>
+#include <iomanip>
+
+using namespace std;
+
+namespace YODA
+{
+
+
+void WriterROOT::writeHeader(std::ostream& os) {}
+void WriterROOT::writeFooter(std::ostream& os) {}
+void WriterROOT::_writeAnnotations(std::ostream& os, const AnalysisObject& ao) { }
+void WriterROOT::writeCounter(std::ostream& os, const Counter& c) { }
+
+void WriterROOT::writeHisto1D(std::ostream& os, const Histo1D& h)
+{
+    if (_ROOTfile) _ROOTfile->cd();
+    else printf("No output ROOT file %s\n",_filename.c_str());
+    TH1D* dps=YODA::Histo1DtoTH1D(&h);
+    if (dps) {  dps->SetDirectory(_ROOTfile); dps->Write( ); dps->SetDirectory(0);}
+}
+
+
+void WriterROOT::writeHisto2D(std::ostream& os, const Histo2D& h) { }
+
+void WriterROOT::writeProfile1D(std::ostream& os, const Profile1D& p)
+{
+    if (_ROOTfile) _ROOTfile->cd();
+    else printf("No output ROOT file %s\n",_filename.c_str());
+    TProfile* dps=YODA::Profile1DtoTProfile(&p);
+    if (dps) { dps->SetDirectory(_ROOTfile); dps->Write(); dps->SetDirectory(0);}
+}
+
+void WriterROOT::writeScatter2D(std::ostream& os, const Scatter2D& s)
+{
+    if (_ROOTfile) _ROOTfile->cd();
+    else printf("No output ROOT file %s\n",_filename.c_str());
+    TGraphAsymmErrors* dps=YODA::Scatter2DtoTGraphAsymmErrors(&s);
+    if (dps)
+        {
+            _ROOTfile->Append(dps),  dps->Write();
+            //dps->SetDirectory(0);
+        }
+    //dps->SetDirectory(0);
+}
+
+
+     void WriterROOT::writeProfile2D(std::ostream& stream, const Profile2D& p){};
+    void WriterROOT::writeScatter1D(std::ostream& stream, const Scatter1D& s){};
+
+     void WriterROOT::writeScatter3D(std::ostream& stream, const Scatter3D& s){};
+
+
+
+
+
+}
