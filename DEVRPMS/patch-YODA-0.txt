diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./include/YODA/ReaderROOT.h ./include/YODA/ReaderROOT.h
--- ./include/YODA/ReaderROOT.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/YODA/ReaderROOT.h	2014-04-15 23:33:25.328871353 +0200
@@ -0,0 +1,299 @@
+// -*- C++ -*-
+//
+// This file is part of YODA -- Yet more Objects for Data Analysis
+//Andrii Verbytskyi, 2014
+//
+#ifndef YODA_READERROOT_H
+#define YODA_READERROOT_H
+
+#include "YODA/AnalysisObject.h"
+#include "YODA/Reader.h"
+#include "YODA/ROOTCnv.h"
+#include <YODA/Scatter2D.h>
+#include <boost/spirit/include/qi.hpp>
+#include <boost/spirit/include/phoenix_operator.hpp>
+#include <boost/fusion/include/adapt_struct.hpp>
+
+
+namespace YODA {
+
+  using namespace boost::spirit;
+  using namespace boost::phoenix;
+
+
+  /// Persistency reader from YODA flat text data format.
+  class ReaderROOT : public Reader {
+  public:
+
+    /// Singleton creation function
+    static Reader& create() {
+      static ReaderROOT _instance;
+      return _instance;
+    }
+
+    static Reader& create(std::string filename) {
+      static ReaderROOT _instance(filename);      
+      return _instance;
+    }
+
+
+    void read(std::istream& stream, std::vector<AnalysisObject*>& aos) {
+      _readDoc(stream, aos);
+    }
+
+
+
+    // Hide from Doxygen until endcond
+    /// @cond
+
+
+  protected:
+
+    void _readDoc(std::istream& stream, std::vector<AnalysisObject*>& aos);
+
+
+  private:
+std::string _filename;
+    void cleanup() {
+      _histo1d.bins.clear();
+      _histo1d.dbn_tot.reset();
+      _histo1d.dbn_uflow.reset();
+      _histo1d.dbn_oflow.reset();
+
+      _profile1d.bins.clear();
+      _profile1d.dbn_tot.reset();
+      _profile1d.dbn_uflow.reset();
+      _profile1d.dbn_oflow.reset();
+
+      _scatter2d.points.clear();
+
+      _annotations.clear();
+    }
+
+  public:
+
+    /// Private constructor, since it's a singleton.
+    /// @todo This is definitely not private!
+
+    ReaderROOT() { }
+    ReaderROOT(std::string filename) {_filename=filename;}
+
+   // Here comes everything we need for the parser
+
+    /// Structs for the Histo1D parser
+    /// The data for Dbn1D
+    struct histo1ddbn {
+      double sumW;
+      double sumW2;
+      double sumWX;
+      double sumWX2;
+      unsigned long numFills;
+    };
+
+    /// A Histo1D bin
+    struct histo1dbin {
+      double lowedge;
+      double highedge;
+      histo1ddbn dbn;
+    };
+
+    /// Structs for the Profile1D parser
+    /// The data for Dbn2D (except sumWXY)
+    struct profile1ddbn {
+      double sumW;
+      double sumW2;
+      double sumWX;
+      double sumWX2;
+      double sumWY;
+      double sumWY2;
+      unsigned long numFills;
+    };
+
+    /// A Profile1D bin
+    struct profile1dbin {
+      double lowedge;
+      double highedge;
+      profile1ddbn dbn;
+    };
+
+    /// Structs for the Scatter2D parser
+    /// The data for ScatterPoint2D
+    struct scatterpoint2d {
+      double x;
+      double exminus;
+      double explus;
+      double y;
+      double eyminus;
+      double eyplus;
+    };
+
+    /// Structs for the key-value pair parser (annotations)
+    struct keyval {
+      std::string key;
+      std::string val;
+    };
+
+
+    /// Annotations (common for all data types)
+    static std::map<std::string, std::string> _annotations;
+
+
+    /// All information for creating a Histo1D
+    struct histo1d {
+      std::vector<YODA::HistoBin1D> bins;
+      YODA::Dbn1D dbn_tot;
+      YODA::Dbn1D dbn_uflow;
+      YODA::Dbn1D dbn_oflow;
+    };
+    static histo1d _histo1d;
+
+
+    /// All information for creating a Profile1D
+    struct profile1d {
+      std::vector<YODA::ProfileBin1D> bins;
+      YODA::Dbn2D dbn_tot;
+      YODA::Dbn2D dbn_uflow;
+      YODA::Dbn2D dbn_oflow;
+    };
+    static profile1d _profile1d;
+
+
+    /// All information for creating a Scatter2D
+    struct scatter2d {
+      std::vector<YODA::Point2D> points;
+    };
+    static scatter2d _scatter2d;
+
+
+    /// Functions to call from the parser
+    /// Filling the dbn_tot
+    struct filltotaldbn {
+      void operator()(const histo1ddbn dbn, qi::unused_type, qi::unused_type) const {
+        _histo1d.dbn_tot = YODA::Dbn1D(dbn.numFills, dbn.sumW, dbn.sumW2, dbn.sumWX, dbn.sumWX2);
+      }
+      void operator()(const profile1ddbn dbn, qi::unused_type, qi::unused_type) const {
+        _profile1d.dbn_tot = YODA::Dbn2D(dbn.numFills, dbn.sumW, dbn.sumW2, dbn.sumWX, dbn.sumWX2, dbn.sumWY, dbn.sumWY2, 0.0);
+      }
+    };
+
+
+    /// Filling the underflow
+    struct filluflowdbn {
+      void operator()(const histo1ddbn dbn, qi::unused_type, qi::unused_type) const {
+        _histo1d.dbn_uflow = YODA::Dbn1D(dbn.numFills, dbn.sumW, dbn.sumW2, dbn.sumWX, dbn.sumWX2);
+      }
+      void operator()(const profile1ddbn dbn, qi::unused_type, qi::unused_type) const {
+        _profile1d.dbn_uflow = YODA::Dbn2D(dbn.numFills, dbn.sumW, dbn.sumW2, dbn.sumWX, dbn.sumWX2, dbn.sumWY, dbn.sumWY2, 0.0);
+      }
+    };
+
+
+    /// Filling the overflow
+    struct filloflowdbn {
+      void operator()(const histo1ddbn dbn, qi::unused_type, qi::unused_type) const {
+        _histo1d.dbn_oflow = YODA::Dbn1D(dbn.numFills, dbn.sumW, dbn.sumW2, dbn.sumWX, dbn.sumWX2);
+      }
+      void operator()(const profile1ddbn dbn, qi::unused_type, qi::unused_type) const {
+        _profile1d.dbn_oflow = YODA::Dbn2D(dbn.numFills, dbn.sumW, dbn.sumW2, dbn.sumWX, dbn.sumWX2, dbn.sumWY, dbn.sumWY2, 0.0);
+      }
+    };
+
+
+    /// Filling a bin
+    struct fillbin {
+      void operator()(const histo1dbin b, qi::unused_type, qi::unused_type) const {
+        YODA::HistoBin1D bin(std::make_pair(b.lowedge, b.highedge), YODA::Dbn1D(b.dbn.numFills, b.dbn.sumW, b.dbn.sumW2, b.dbn.sumWX, b.dbn.sumWX2));
+        _histo1d.bins.push_back(bin);
+      }
+      void operator()(const profile1dbin b, qi::unused_type, qi::unused_type) const {
+        YODA::ProfileBin1D bin(std::make_pair(b.lowedge, b.highedge), YODA::Dbn2D(b.dbn.numFills, b.dbn.sumW, b.dbn.sumW2, b.dbn.sumWX, b.dbn.sumWX2, b.dbn.sumWY, b.dbn.sumWY2, 0.0));
+        _profile1d.bins.push_back(bin);
+      }
+    };
+
+
+    /// Filling a point
+    struct fillpoint {
+      void operator()(const scatterpoint2d p, qi::unused_type, qi::unused_type) const {
+        YODA::Point2D point(p.x, p.y, p.exminus, p.explus, p.eyminus, p.eyplus);
+        _scatter2d.points.push_back(point);
+      }
+    };
+
+
+    /// Filling the annotations map
+    struct fillkeyval {
+      void operator()(const keyval m, qi::unused_type, qi::unused_type) const {
+        _annotations[m.key] = m.val;
+      }
+    };
+
+
+
+/// @endcond
+
+};
+
+} // end of YODA namespace
+
+
+
+// Now we need to make boost aware of the structs we want to
+// fill directly from the parser. Boost wants this magic in
+// the global scope, that's why we have it outside the namespace.
+
+/// @cond PRIVATE
+
+BOOST_FUSION_ADAPT_STRUCT(
+  YODA::ReaderROOT::histo1ddbn,
+  (double, sumW)
+  (double, sumW2)
+  (double, sumWX)
+  (double, sumWX2)
+  (unsigned long, numFills)
+)
+
+BOOST_FUSION_ADAPT_STRUCT(
+  YODA::ReaderROOT::histo1dbin,
+  (double, lowedge)
+  (double, highedge)
+  (YODA::ReaderROOT::histo1ddbn, dbn)
+)
+
+BOOST_FUSION_ADAPT_STRUCT(
+  YODA::ReaderROOT::profile1ddbn,
+  (double, sumW)
+  (double, sumW2)
+  (double, sumWX)
+  (double, sumWX2)
+  (double, sumWY)
+  (double, sumWY2)
+  (unsigned long, numFills)
+)
+
+BOOST_FUSION_ADAPT_STRUCT(
+  YODA::ReaderROOT::profile1dbin,
+  (double, lowedge)
+  (double, highedge)
+  (YODA::ReaderROOT::profile1ddbn, dbn)
+)
+
+BOOST_FUSION_ADAPT_STRUCT(
+  YODA::ReaderROOT::scatterpoint2d,
+  (double, x)
+  (double, exminus)
+  (double, explus)
+  (double, y)
+  (double, eyminus)
+  (double, eyplus)
+)
+
+BOOST_FUSION_ADAPT_STRUCT(
+  YODA::ReaderROOT::keyval,
+  (std::string, key)
+  (std::string, val)
+)
+
+/// @endcond
+
+#endif
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./include/YODA/ROOTCnv.h ./include/YODA/ROOTCnv.h
--- ./include/YODA/ROOTCnv.h	2013-06-06 09:50:30.000000000 +0200
+++ ./include/YODA/ROOTCnv.h	2014-04-15 23:33:25.327871363 +0200
@@ -15,6 +15,11 @@
 #include "TProfile.h"
 #include "TGraphAsymmErrors.h"
 #include "TVectorF.h"
+#include "TFile.h"
+#include "TList.h"
+#include "TKey.h"
+#include "TClass.h"
+#include "TH1F.h"
 
 namespace YODA {
 
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./pyext/yoda/core.pyx ./pyext/yoda/core.pyx
--- ./pyext/yoda/core.pyx	2014-03-06 13:57:21.000000000 +0100
+++ ./pyext/yoda/core.pyx	2014-04-15 23:33:25.340871225 +0200
@@ -32,5 +32,5 @@
 include "include/HistoBin2D.pyx"
 include "include/Histo2D.pyx"
 include "include/Profile2D.pyx"
-include "include/Functions.pyx"
+##include "include/Functions.pyx"
 include "include/IO.pyx"
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./pyext/yoda/declarations.pxd ./pyext/yoda/declarations.pxd
--- ./pyext/yoda/declarations.pxd	2014-03-06 16:09:32.000000000 +0100
+++ ./pyext/yoda/declarations.pxd	2014-04-15 23:33:25.339871236 +0200
@@ -969,6 +969,9 @@
 cdef extern from "YODA/ReaderFLAT.h" namespace "YODA":
     Reader& ReaderFLAT_create "YODA::ReaderFLAT::create" ()
 
+cdef extern from "YODA/ReaderROOT.h" namespace "YODA":
+    Reader& ReaderROOT_create "YODA::ReaderROOT::create" ()
+
 cdef extern from "YODA/ReaderAIDA.h" namespace "YODA":
     Reader& ReaderAIDA_create "YODA::ReaderAIDA::create" ()
 
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./pyext/yoda/Makefile.am ./pyext/yoda/Makefile.am
--- ./pyext/yoda/Makefile.am	2014-02-27 13:36:12.000000000 +0100
+++ ./pyext/yoda/Makefile.am	2014-04-15 23:33:25.331871321 +0200
@@ -40,6 +40,10 @@
     mktemplates \
     core.cpp core.h util.cpp
 
+if ENABLE_ROOT
+  CXXFLAGS += $(ROOT_CXXFLAGS) -Wno-long-long 
+endif
+
 
 if WITH_CYTHON
 core.cpp: $(CYTHON_SRC)
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./pyext/yoda/mktemplates ./pyext/yoda/mktemplates
--- ./pyext/yoda/mktemplates	2014-02-27 13:26:19.000000000 +0100
+++ ./pyext/yoda/mktemplates	2014-04-15 23:33:25.340871225 +0200
@@ -50,9 +50,9 @@
     #print plain_name
 
     try:
-        os.mkdir("generated")
+        os.mkdir("include/generated")
     except OSError as exc: # Python >2.5
-        if exc.errno == errno.EEXIST and os.path.isdir("generated"):
+        if exc.errno == errno.EEXIST and os.path.isdir("include/generated"):
             pass
         else: raise
 
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./src/Makefile.am ./src/Makefile.am
--- ./src/Makefile.am	2013-10-24 21:06:20.000000000 +0200
+++ ./src/Makefile.am	2014-04-15 23:33:25.341871214 +0200
@@ -21,6 +21,12 @@
     Scatter2D.cc \
     Scatter3D.cc
 
-libYODA_la_LDFLAGS = -avoid-version
+libYODA_la_LDFLAGS = -avoid-version 
 libYODA_la_LIBADD = tinyxml/libtinyxml.la
-libYODA_la_CPPFLAGS = $(AM_CPPFLAGS) -DTIXML_USE_STL
+libYODA_la_CPPFLAGS = $(AM_CPPFLAGS) -DTIXML_USE_STL 
+
+if  ENABLE_ROOT
+libYODA_la_SOURCES += ReaderROOT.cc 
+libYODA_la_LDFLAGS += $(ROOT_LDFLAGS)
+libYODA_la_CPPFLAGS += $(ROOT_CXXFLAGS) -Wno-long-long 
+endif
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./src/Reader.cc ./src/Reader.cc
--- ./src/Reader.cc	2013-05-30 16:23:07.000000000 +0200
+++ ./src/Reader.cc	2014-04-15 23:33:25.344871182 +0200
@@ -5,6 +5,7 @@
 //
 #include "YODA/Reader.h"
 #include "YODA/ReaderYODA.h"
+#include "YODA/ReaderROOT.h"
 #include "YODA/ReaderAIDA.h"
 #include "YODA/ReaderFLAT.h"
 
@@ -19,6 +20,7 @@
     if (fmt == "yoda") return ReaderYODA::create();
     if (fmt == "aida") return ReaderAIDA::create();
     if (fmt == "dat")  return ReaderFLAT::create();
+    if (fmt == "root") return ReaderROOT::create(name);
     throw UserError("Format cannot be identified from string '" + name + "'");
   }
 
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./src/ReaderROOT.cc ./src/ReaderROOT.cc
--- ./src/ReaderROOT.cc	1970-01-01 01:00:00.000000000 +0100
+++ ./src/ReaderROOT.cc	2014-04-15 23:33:25.341871214 +0200
@@ -0,0 +1,166 @@
+// -*- C++ -*-
+//
+// This file is part of YODA -- Yet more Objects for Data Analysis
+// Copyright (C) 2008-2013 The YODA collaboration (see AUTHORS for details)
+//
+
+#include "YODA/ReaderROOT.h"
+#include "YODA/Utils/StringUtils.h"
+#include "YODA/Exceptions.h"
+
+#include <iostream>
+
+
+
+using namespace std;
+
+namespace YODA {
+  ReaderROOT::histo1d ReaderROOT::_histo1d;
+  ReaderROOT::profile1d ReaderROOT::_profile1d;
+  ReaderROOT::scatter2d ReaderROOT::_scatter2d;
+  std::map<std::string, std::string> ReaderROOT::_annotations;
+
+
+  
+
+ void ReaderROOT::_readDoc(std::istream& stream, vector<AnalysisObject*>& aos) {
+   
+std::string streama=_filename; //Ugly trick;
+TFile* fin = new TFile(streama.c_str()) ;
+  if (!fin->IsOpen()) {
+    printf("<E> Cannot open input file %s\n",streama.c_str()) ;
+    exit(1) ;
+  }
+  
+  TList* list = fin->GetListOfKeys() ;
+  if (!list) { printf("<E> No keys found in file\n") ; exit(1) ; }
+  
+  TIter next(list) ;
+  TKey* key ;
+  TObject* obj ;
+      
+  while ( key = (TKey*)next() ) {
+    obj = key->ReadObj() ;
+    int type=-1;
+    
+
+    
+    
+    if (strcmp(obj->IsA()->GetName(),"TProfile")==0) type=0;
+    if (obj->InheritsFrom("TH1")) 
+    {
+    
+    if (strcmp(obj->IsA()->GetName(),"TH1F")==0)type=11;
+    if (strcmp(obj->IsA()->GetName(),"TH1D")==0) type=12;
+    
+    
+}
+    if (obj->InheritsFrom("TH2")) type=2;
+    if (obj->InheritsFrom("TGraph")) 
+    {
+    if (strcmp(obj->IsA()->GetName(),"TGraph")==0)type=31;
+    if (strcmp(obj->IsA()->GetName(),"TGraphErrors")==0) type=32;
+    if (strcmp(obj->IsA()->GetName(),"TGraphAsymmErrors")==0)type=33;
+    }
+    
+    
+    if (type==-1)  printf("<W> Object %s  has unsupported type %s and will not be converted\n",obj->GetName(),obj->IsA()->GetName()) ;
+    if (type==0)   printf("<W> Object %s has unsupported type TProfile\n",obj->GetName()) ; 
+    if (type/10==1)
+    {
+
+#define TH1_IS_SCATTER2D
+
+#ifdef TH1_IS_SCATTER2D
+            char a[255];
+            sprintf(a,"/%s/%s",streama.c_str(),obj->GetName());
+	        Scatter2D* dps = new Scatter2D(a);
+	        
+	        		    TH1* HH= (TH1*)(obj); 
+	        
+                for (int i = 1; i <= HH->GetNbinsX(); ++i) {
+      const double x = HH->GetBinCenter(i);
+      const double exminus = x - HH->GetBinLowEdge(i);
+      const double explus = HH->GetBinLowEdge(i+1) - x;
+      const double width = exminus + explus;
+      dps->addPoint(x, HH->GetBinContent(i)/width,
+                   exminus, explus,
+                   HH->GetBinErrorLow(i)/width, HH->GetBinErrorUp(i)/width);
+    }
+    dps->setAnnotation("Title", obj->GetTitle());
+    dps->setAnnotation("XLabel", HH->GetXaxis()->GetTitle());
+    dps->setAnnotation("YLabel", HH->GetYaxis()->GetTitle());
+            aos.push_back(dps);
+#else
+            char a[255];
+            sprintf(a,"/%s/%s",streama.c_str(),obj->GetName());
+            YODA::Histo1D* dps = new YODA::Histo1D(a);//_histo1d.bins, _histo1d.dbn_tot, _histo1d.dbn_uflow, _histo1d.dbn_oflow);
+	        int i;
+
+            if (type==11) { 
+		    TH1F* HHF= (TH1F*)(obj); 
+	        if (HHF->GetNbinsX()>0){
+	        for (i=1;i<HHF->GetNbinsX();i++)
+		     dps->addBin(HHF->GetBinLowEdge(i),HHF->GetBinLowEdge(i)+ HHF->GetBinWidth(i));
+            dps->setAnnotation("Title", obj->GetTitle());
+            dps->setAnnotation("TitleX", HHF->GetXaxis()->GetTitle());
+            dps->setAnnotation("TitleY", HHF->GetYaxis()->GetTitle());
+	        for (i=1;i<HHF->GetNbinsX();i++) dps->fill(HHF->GetBinCenter(i), HHF->GetBinContent(i));
+		     }
+		     aos.push_back(dps);
+		    }
+		    
+            if (type==12) { 
+		    TH1D* HHD= (TH1D*)(obj); 
+	        if (HHD->GetNbinsX()>0){
+	        for (i=1;i<HHD->GetNbinsX();i++)
+		     dps->addBin(HHD->GetBinLowEdge(i),HHD->GetBinLowEdge(i)+ HHD->GetBinWidth(i));
+            dps->setAnnotation("Title", obj->GetTitle());
+            dps->setAnnotation("TitleX", HHD->GetXaxis()->GetTitle());
+            dps->setAnnotation("TitleY", HHD->GetYaxis()->GetTitle());
+	        for (i=1;i<HHD->GetNbinsX();i++) dps->fill(HHD->GetBinCenter(i), HHD->GetBinContent(i));
+		     }
+            aos.push_back(dps);
+    		 }
+
+
+#endif           
+    	    	 cleanup();
+    }
+    if (type==2)   printf("<W> Object %s has unsupported type TH2\n",obj->GetName()) ; 
+    if (type/10==3)
+    {
+            char a[255];
+            sprintf(a,"/%s/%s",streama.c_str(),obj->GetName());
+	        Scatter2D* dps = new Scatter2D(a);
+	        int i;
+	        TGraphAsymmErrors* HH=(TGraphAsymmErrors*)obj;
+
+	        for (i=0;i<HH->GetN()-1;i++)
+	        {
+	        double x,y;
+	        HH->GetPoint(i,x,y);
+	        dps->addPoint(x, y,
+	        HH->GetErrorXlow(i),
+	        HH->GetErrorXhigh(i),
+	        HH->GetErrorYlow(i),
+	        HH->GetErrorYhigh(i)
+	        );
+		    }
+            dps->setAnnotation("Title", obj->GetTitle());
+            dps->setAnnotation("TitleX", HH->GetXaxis()->GetTitle());
+            dps->setAnnotation("TitleY", HH->GetYaxis()->GetTitle());
+            aos.push_back(dps);
+            cleanup();
+		     }
+
+
+
+  }
+fin->Close();
+}
+
+
+
+
+}
