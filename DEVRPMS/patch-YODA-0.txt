diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./include/YODA/Makefile.am ./include/YODA/Makefile.am
--- ./include/YODA/Makefile.am	2014-12-08 20:35:33.214524828 +0200
+++ ./include/YODA/Makefile.am	2014-12-08 20:35:33.226524677 +0200
@@ -18,6 +18,10 @@
     Reader.h ReaderAIDA.h ReaderYODA.h ReaderFLAT.h \
     IO.h ROOTCnv.h
 
+if  ENABLE_ROOT
+pkginclude_HEADERS+=WriterROOT.h ReaderROOT.h ROOTConvert.h
+endif
+
 nobase_pkginclude_HEADERS = \
 	WriterMethods.icc \
 	Utils/StringUtils.h \
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./include/YODA/ReaderROOT.h ./include/YODA/ReaderROOT.h
--- ./include/YODA/ReaderROOT.h	1970-01-01 03:00:00.000000000 +0300
+++ ./include/YODA/ReaderROOT.h	2014-12-08 20:35:33.227524664 +0200
@@ -0,0 +1,75 @@
+// -*- C++ -*-
+//
+// This file is part of YODA -- Yet more Objects for Data Analysis
+//Andrii Verbytskyi, 2014
+//
+#ifndef YODA_READERROOT_H
+#define YODA_READERROOT_H
+
+#include "YODA/AnalysisObject.h"
+#include "YODA/Reader.h"
+#include "YODA/ROOTConvert.h"
+#include <YODA/Scatter2D.h>
+#include <boost/spirit/include/qi.hpp>
+#include <boost/spirit/include/phoenix_operator.hpp>
+#include <boost/fusion/include/adapt_struct.hpp>
+
+
+namespace YODA {
+
+  using namespace boost::spirit;
+  using namespace boost::phoenix;
+
+
+  /// Persistency reader from YODA flat text data format.
+  class ReaderROOT : public Reader {
+  public:
+
+    /// Singleton creation function
+    static Reader& create() {
+      static ReaderROOT _instance;
+      return _instance;
+    }
+
+    static Reader& create(std::string filename) {
+      static ReaderROOT _instance(filename);      
+      return _instance;
+    }
+
+
+    void read(std::istream& stream, std::vector<AnalysisObject*>& aos) {
+      _readDoc(stream, aos);
+    }
+
+
+
+    // Hide from Doxygen until endcond
+    /// @cond
+
+
+  protected:
+
+    void _readDoc(std::istream& stream, std::vector<AnalysisObject*>& aos);
+
+
+  private:
+std::string _filename;
+
+
+  public:
+
+    /// Private constructor, since it's a singleton.
+    /// @todo This is definitely not private!
+
+    ReaderROOT() { }
+    ReaderROOT(std::string filename) {_filename=filename;}
+
+  
+};
+
+} // end of YODA namespace
+
+
+/// @endcond
+
+#endif
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./include/YODA/ROOTConvert.h ./include/YODA/ROOTConvert.h
--- ./include/YODA/ROOTConvert.h	1970-01-01 03:00:00.000000000 +0300
+++ ./include/YODA/ROOTConvert.h	2014-12-08 20:35:33.229524638 +0200
@@ -0,0 +1,36 @@
+// AV 2014
+#ifndef YODA_ROOTConvert_h
+#define YODA_ROOTConvert_h
+
+#include "YODA/Histo1D.h"
+#include "YODA/Histo2D.h"
+#include "YODA/Profile1D.h"
+#include "YODA/Histo1D.h"
+#include "YODA/Profile1D.h"
+#include "YODA/Scatter2D.h"
+#include "TH1.h"
+#include "TH2.h"
+#include "TProfile.h"
+#include "TGraphAsymmErrors.h"
+#include "TVectorF.h"
+#include "TFile.h"
+#include "TList.h"
+#include "TKey.h"
+#include "TClass.h"
+#include "TH1F.h"
+#include <string>
+
+namespace YODA {
+
+Histo1D*           TH1toHisto1D  (const TH1* th1, std::string fname="");
+TH1D*              Histo1DtoTH1D(const Histo1D* h) ;
+
+Profile1D*         TProfiletoProfile1D(const TProfile*  p, std::string fname="") ;
+TProfile*          Profile1DtoTProfile(const Profile1D* p) ;
+
+Scatter2D*         TGraphtoScatter2D(const TGraph* g, std::string fname="") ;
+TGraphAsymmErrors* Scatter2DtoTGraphAsymmErrors(const Scatter2D* s) ;
+
+}
+
+#endif
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./include/YODA/WriterROOT.h ./include/YODA/WriterROOT.h
--- ./include/YODA/WriterROOT.h	1970-01-01 03:00:00.000000000 +0300
+++ ./include/YODA/WriterROOT.h	2014-12-08 20:35:33.227524664 +0200
@@ -0,0 +1,72 @@
+// -*- C++ -*-
+//
+// This file is part of YODA -- Yet more Objects for Data Analysis
+// Copyright (C) 2008-2013 The YODA collaboration (see AUTHORS for details)
+//
+#ifndef YODA_WRITERROOT_H
+#define YODA_WRITERROOT_H
+
+#include "YODA/AnalysisObject.h"
+#include "YODA/Writer.h"
+#include "YODA/ROOTConvert.h"
+#include <vector>
+#include <string>
+#include <ostream>
+
+
+namespace YODA {
+
+
+  /// Persistency writer for flat text format.
+  class WriterROOT : public Writer {
+  public:
+
+    /// Singleton creation function
+    static Writer& create() {
+      static WriterROOT _instance;
+      _instance.setPrecision(6);
+      return _instance;
+    }
+
+    static Writer& create(std::string filename) {
+      static WriterROOT _instance(filename);
+      _instance.setPrecision(6);
+      return _instance;
+    }
+
+
+    // Include definitions of all write methods (all fulfilled by Writer::write(...))
+    #include "YODA/WriterMethods.icc"
+
+
+  protected:
+
+    void writeHeader(std::ostream& stream);
+    //void writeBody(std::ostream& stream, const AnalysisObject& ao);
+    void writeFooter(std::ostream& stream);
+  //void write(const std::string& filename, const AnalysisObject& ao);
+    void writeCounter(std::ostream& stream, const Counter& c);
+    void writeHisto1D(std::ostream& stream, const Histo1D& h);
+    void writeHisto2D(std::ostream& stream, const Histo2D& h);
+    void writeProfile1D(std::ostream& stream, const Profile1D& p);
+     void writeProfile2D(std::ostream& stream, const Profile2D& p);
+    void writeScatter1D(std::ostream& stream, const Scatter1D& s);
+    void writeScatter2D(std::ostream& stream, const Scatter2D& s);
+     void writeScatter3D(std::ostream& stream, const Scatter3D& s);
+
+
+  private:
+std::string _filename;
+TFile* _ROOTfile;
+    void _writeAnnotations(std::ostream& os, const AnalysisObject& ao);
+
+    /// Private since it's a singleton.
+    WriterROOT() { }
+    WriterROOT(std::string filename) {  _filename=filename; _ROOTfile=new TFile(filename.c_str(),"recreate");  }
+     ~WriterROOT() {if (_ROOTfile) _ROOTfile->Close();}
+  };
+
+
+}
+
+#endif
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./pyext/Makefile.am ./pyext/Makefile.am
--- ./pyext/Makefile.am	2014-12-08 20:35:33.093526360 +0200
+++ ./pyext/Makefile.am	2014-12-08 20:35:33.231524614 +0200
@@ -4,7 +4,7 @@
 PYEXT_ENV = CC="$(CC)" CXX="$(CXX)" CXXFLAGS="$(PYEXT_CXXFLAGS)" ARCHFLAGS=""
 
 if ENABLE_ROOT
-  PYEXT_ENV += BUILD_ROOTCOMPAT="yes"
+  PYEXT_ENV = CC="$(CXX)" CXX="$(CXX)" CXXFLAGS="$(PYEXT_CXXFLAGS) $(ROOT_CXXFLAGS) -Wno-long-long  -DENABLE_ROOT" CFLAGS="$(PYEXT_CFLAGS) $(ROOT_CXXFLAGS) -Wno-long-long  -DENABLE_ROOT" ARCHFLAGS="" BUILD_ROOTCOMPAT="yes"
 endif
 
 ## Always force setup.py, it's not good at guessing what needs to rebuild
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./pyext/yoda/declarations.pxd ./pyext/yoda/declarations.pxd
--- ./pyext/yoda/declarations.pxd	2014-12-08 20:35:33.095526334 +0200
+++ ./pyext/yoda/declarations.pxd	2014-12-08 20:35:33.238524525 +0200
@@ -1217,6 +1217,9 @@
 cdef extern from "YODA/ReaderFLAT.h" namespace "YODA":
     Reader& ReaderFLAT_create "YODA::ReaderFLAT::create" ()
 
+cdef extern from "YODA/ReaderROOT.h" namespace "YODA":
+    Reader& ReaderROOT_create "YODA::ReaderROOT::create" ()
+
 cdef extern from "YODA/ReaderAIDA.h" namespace "YODA":
     Reader& ReaderAIDA_create "YODA::ReaderAIDA::create" ()
 
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./pyext/yoda/Makefile.am ./pyext/yoda/Makefile.am
--- ./pyext/yoda/Makefile.am	2014-12-08 20:35:33.093526360 +0200
+++ ./pyext/yoda/Makefile.am	2014-12-08 20:35:33.231524614 +0200
@@ -46,9 +46,14 @@
     mktemplates \
     core.cpp core.h util.cpp
 
+if ENABLE_ROOT
+  CXXFLAGS += $(ROOT_CXXFLAGS) -Wno-long-long 
+endif
+
 
 if WITH_CYTHON
-core.cpp core.h: $(CYTHON_SRC) .made_pyx_templates
+core.cpp core.h: $(CYTHON_SRC)
+	./mktemplates
 	cython core.pyx --cplus
 else
 core.cpp core.h: $(CYTHON_SRC)
@@ -57,7 +62,8 @@
 
 
 if WITH_CYTHON
-util.cpp: util.pxd util.pyx .made_pyx_templates
+util.cpp: util.pxd util.pyx
+	./mktemplates
 	cython util.pyx --cplus
 else
 util.cpp: util.pxd util.pyx
@@ -72,7 +78,8 @@
 	@true
 
 if WITH_CYTHON
-rootcompat.cpp: util.pxd rootcompat.pxd rootcompat.pyx .made_pyx_templates
+rootcompat.cpp: util.pxd rootcompat.pxd rootcompat.pyx
+	./mktemplates
 	cython rootcompat.pyx --cplus
 else
 rootcompat.cpp: util.pxd rootcompat.pxd rootcompat.pyx
@@ -80,10 +87,6 @@
 endif
 
 
-## Make text-substitution .pyx files from templates -- should only run once
-.made_pyx_templates: include/Bin1D_DBN.pyx include/Bin2D_DBN.pyx include/Axis1D_BIN1D_DBN.pyx include/Axis2D_BIN2D_DBN.pyx
-	./mktemplates
-	touch $@
 
 
 ## fixes for out-of-source builds, especially "make distcheck"
@@ -109,4 +112,4 @@
 	rm -f $<
 
 distclean-local:
-	rm -f core.cpp core.h util.cpp rootcompat.cpp include/generated/* .made_pyx_templates
+	rm -f core.cpp core.h util.cpp rootcompat.cpp include/generated/*
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./pyext/yoda/mktemplates ./pyext/yoda/mktemplates
--- ./pyext/yoda/mktemplates	2014-12-08 20:35:33.100526269 +0200
+++ ./pyext/yoda/mktemplates	2014-12-08 20:35:33.238524525 +0200
@@ -52,8 +52,9 @@
     try:
         os.mkdir("include/generated")
     except OSError as exc: # Python >2.5
-        if exc.errno != errno.EEXIST or not os.path.isdir("include/generated"):
-            raise
+        if exc.errno == errno.EEXIST and os.path.isdir("include/generated"):
+            pass
+        else: raise
 
     includes = []
     for a in individuals:
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./pyext/yoda/rootcompat.pxd ./pyext/yoda/rootcompat.pxd
--- ./pyext/yoda/rootcompat.pxd	2014-12-08 20:35:33.094526347 +0200
+++ ./pyext/yoda/rootcompat.pxd	2014-12-08 20:35:33.232524602 +0200
@@ -28,8 +28,8 @@
 cdef extern from "pyroot_helpers.hh":
     cpython.PyObject* root_to_py_owned(TObject* root_obj)
 
-cdef extern from "YODA/ROOTCnv.h" namespace "YODA":
-    Scatter2D toScatter2D(TH1*)
-    TH1D toTH1D(Histo1D)
-    TProfile toTProfile(Profile1D)
-    TGraphAsymmErrors toTGraph(Scatter2D)
+#cdef extern from "YODA/ROOTCnv.h" namespace "YODA":
+#    Scatter2D toScatter2D(TH1*)
+#    TH1D toTH1D(Histo1D)
+#    TProfile toTProfile(Profile1D)
+#    TGraphAsymmErrors toTGraph(Scatter2D)
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./pyext/yoda/rootcompat.pyx ./pyext/yoda/rootcompat.pyx
--- ./pyext/yoda/rootcompat.pyx	2014-12-08 20:35:33.094526347 +0200
+++ ./pyext/yoda/rootcompat.pyx	2014-12-08 20:35:33.232524602 +0200
@@ -24,26 +24,27 @@
 
     cdef void *ptr = yoda_obj.ptr()
 
-    if isinstance(yoda_obj, yoda.Histo1D):
-        return _toTH1D(<cyoda.Histo1D*> ptr)
+    return <object> ptr
+#    if isinstance(yoda_obj, yoda.Histo1D):
+#        return _toTH1D(<cyoda.Histo1D*> ptr)
 
-    elif isinstance(yoda_obj, yoda.Profile1D):
-        return _toTProfile(<cyoda.Profile1D*> ptr)
+#    elif isinstance(yoda_obj, yoda.Profile1D):
+#        return _toTProfile(<cyoda.Profile1D*> ptr)
 
-    elif isinstance(yoda_obj, yoda.Scatter2D):
-        return _toTGraph(<cyoda.Scatter2D*> ptr)
+#    elif isinstance(yoda_obj, yoda.Scatter2D):
+#        return _toTGraph(<cyoda.Scatter2D*> ptr)
 
 cdef object root_to_py(c.TObject* tobj):
     return <object> c.root_to_py_owned(tobj)
 
-cdef _toTH1D(cyoda.Histo1D* h1d):
-    return ROOT.TH1D(
-        root_to_py(new c.TH1D(c.toTH1D(deref(h1d)))))
-
-cdef _toTProfile(cyoda.Profile1D* p1d):
-    return ROOT.TProfile(
-        root_to_py(new c.TProfile(c.toTProfile(deref(p1d)))))
-
-cdef _toTGraph(cyoda.Scatter2D* s2d):
-    return ROOT.TGraphAsymmErrors(
-        root_to_py(new c.TGraphAsymmErrors(c.toTGraph(deref(s2d)))))
+#cdef _toTH1D(cyoda.Histo1D* h1d):
+#    return ROOT.TH1D(
+#        root_to_py(new c.TH1D(c.toTH1D(deref(h1d)))))
+
+#cdef _toTProfile(cyoda.Profile1D* p1d):
+#    return ROOT.TProfile(
+#        root_to_py(new c.TProfile(c.toTProfile(deref(p1d)))))
+
+#cdef _toTGraph(cyoda.Scatter2D* s2d):
+#    return ROOT.TGraphAsymmErrors(
+#        root_to_py(new c.TGraphAsymmErrors(c.toTGraph(deref(s2d)))))
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./src/Makefile.am ./src/Makefile.am
--- ./src/Makefile.am	2014-12-08 20:35:33.117526054 +0200
+++ ./src/Makefile.am	2014-12-08 20:35:33.240524501 +0200
@@ -27,3 +27,13 @@
 libYODA_la_LDFLAGS = -avoid-version
 libYODA_la_LIBADD = tinyxml/libtinyxml.la
 libYODA_la_CPPFLAGS = $(AM_CPPFLAGS) -DTIXML_USE_STL
+
+if  ENABLE_ROOT
+libYODA_la_SOURCES += ROOTConvert.cc 
+libYODA_la_SOURCES += ReaderROOT.cc 
+libYODA_la_SOURCES += WriterROOT.cc 
+libYODA_la_LDFLAGS += $(ROOT_LDFLAGS) $(ROOT_LIBS)
+libYODA_la_CPPFLAGS += $(ROOT_CXXFLAGS) -Wno-long-long 
+#libYODA_la_CXXFLAGS += $(ROOT_CXXFLAGS) -Wno-long-long 
+
+endif
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./src/Reader.cc ./src/Reader.cc
--- ./src/Reader.cc	2014-12-08 20:35:33.117526054 +0200
+++ ./src/Reader.cc	2014-12-08 20:35:33.240524501 +0200
@@ -5,6 +5,9 @@
 //
 #include "YODA/Reader.h"
 #include "YODA/ReaderYODA.h"
+#ifdef ENABLE_ROOT
+#include "YODA/ReaderROOT.h"
+#endif
 #include "YODA/ReaderAIDA.h"
 #include "YODA/ReaderFLAT.h"
 
@@ -20,6 +23,9 @@
     if (fmt == "yoda") return ReaderYODA::create();
     if (fmt == "aida") return ReaderAIDA::create();
     if (fmt == "dat" || fmt == "flat")  return ReaderFLAT::create();
+#ifdef ENABLE_ROOT
+    if (fmt == "root") return ReaderROOT::create(name);
+#endif
     throw UserError("Format cannot be identified from string '" + name + "'");
   }
 
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./src/ReaderROOT.cc ./src/ReaderROOT.cc
--- ./src/ReaderROOT.cc	1970-01-01 03:00:00.000000000 +0300
+++ ./src/ReaderROOT.cc	2014-12-08 20:35:33.243524462 +0200
@@ -0,0 +1,85 @@
+// -*- C++ -*-
+//
+// This file is part of YODA -- Yet more Objects for Data Analysis
+// Copyright (C) 2008-2013 The YODA collaboration (see AUTHORS for details)
+//
+
+#include "YODA/ReaderROOT.h"
+#include "YODA/Utils/StringUtils.h"
+#include "YODA/Exceptions.h"
+#include <iostream>
+
+
+
+using namespace std;
+
+namespace YODA
+{
+
+void ReaderROOT::_readDoc(std::istream& stream, vector<AnalysisObject*>& aos)
+{
+    std::string streama=_filename; //Ugly trick;
+    TFile* fin = new TFile(streama.c_str()) ;
+    if (!fin->IsOpen())
+        {
+            printf("Cannot open input file %s\n",streama.c_str()) ;
+            exit(1) ;
+        }
+
+    TList* list = fin->GetListOfKeys() ;
+    if (!list) { printf("No keys found in file %s\n",streama.c_str()) ; exit(1) ; }
+
+    TIter next(list) ;
+    TKey* key ;
+    TObject* obj ;
+
+    while ( key = (TKey*)next() )
+        {
+            obj = key->ReadObj() ;
+            int type=-1;
+
+            if (strcmp(obj->IsA()->GetName(),"TProfile")==0) type=0;
+            if (strcmp(obj->IsA()->GetName(),"TH1F")==0)type=11;
+            if (strcmp(obj->IsA()->GetName(),"TH1D")==0) type=12;
+            if (obj->InheritsFrom("TH2")) type=2;
+            if (strcmp(obj->IsA()->GetName(),"TGraph")==0)type=31;
+            if (strcmp(obj->IsA()->GetName(),"TGraphErrors")==0) type=32;
+            if (strcmp(obj->IsA()->GetName(),"TGraphAsymmErrors")==0)type=33;
+            if (type==-1)  printf("Object %s  has unsupported type %s and will not be converted\n",obj->GetName(),obj->IsA()->GetName()) ;
+            if (type==0)
+                {
+                    TProfile* P= (TProfile*)(obj);
+                    YODA::Profile1D* dps = TProfiletoProfile1D(P,_filename);
+                    aos.push_back(dps);
+                }
+            if (type==11||type==12)
+                {
+                    /*
+                    The mapping is TH? <-> Histo?D, TProfile <-> Profile1D, TGraph <-> Scatter2D.
+                    */
+
+                    if (type==11)
+                        {
+                            TH1F* HHF= (TH1F*)(obj);
+                            YODA::Histo1D* dps=YODA::TH1toHisto1D(HHF,_filename);
+                            aos.push_back(dps);
+                        }
+                    if (type==12)
+                        {
+                            TH1D* HHD= (TH1D*)(obj);
+                            YODA::Histo1D* dps=YODA::TH1toHisto1D(HHD);
+                            aos.push_back(dps);
+                        }
+                }
+            if (type==2)   printf("<W> Object %s has unsupported type TH2\n",obj->GetName()) ;
+            if (type==31||type==32||type==33)
+                {
+                    TGraphAsymmErrors* G=(TGraphAsymmErrors*)obj;
+                    Scatter2D* dps = YODA::TGraphtoScatter2D(G,_filename);
+                    aos.push_back(dps);
+                }
+        }
+    fin->Close();
+}
+
+}
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./src/ROOTConvert.cc ./src/ROOTConvert.cc
--- ./src/ROOTConvert.cc	1970-01-01 03:00:00.000000000 +0300
+++ ./src/ROOTConvert.cc	2014-12-08 20:35:33.240524501 +0200
@@ -0,0 +1,233 @@
+// -*- C++ -*-
+//
+// This file is part of YODA -- Yet more Objects for Data Analysis
+// Copyright (C) 2008-2013 The YODA collaboration (see AUTHORS for details)
+//
+#ifndef YODA_ROOTCnv_h
+#define YODA_ROOTCnv_h
+
+#include "YODA/ROOTConvert.h"
+#include "YODA/Histo1D.h"
+#include "YODA/Histo2D.h"
+#include "YODA/Histo1D.h"
+#include "YODA/Profile1D.h"
+#include "YODA/Scatter2D.h"
+
+#include "TH1.h"
+#include "TH2.h"
+#include "TProfile.h"
+#include "TGraphAsymmErrors.h"
+#include "TVectorF.h"
+#include "TFile.h"
+#include "TList.h"
+#include "TKey.h"
+#include "TClass.h"
+#include "TH1F.h"
+#include <string>
+
+namespace YODA
+{
+
+Histo1D* TH1toHisto1D(const TH1* th1, std::string fname)
+{
+    std::vector<HistoBin1D> bins;
+    const TArrayD* sumw2s = th1->GetSumw2();
+    Dbn1D dbn_uflow, dbn_oflow;
+    double sumWtot=0, sumW2tot=0;
+    for (int i = 0; i <= th1->GetNbinsX()+1; ++i)
+        {
+            Dbn1D dbn(static_cast<unsigned long>(th1->GetBinContent(i)), th1->GetBinContent(i), sumw2s->GetAt(i) 
+                      , 0, 0);
+            //th1->GetBinContent(i)*th1->GetBinCenter(i), th1->GetBinContent(i)*sqr(th1->GetBinCenter(i)));
+            if (i == 0) dbn_uflow = dbn;
+            else if (i == th1->GetNbinsX()+1) dbn_oflow = dbn;
+            else bins.push_back(HistoBin1D(std::make_pair(th1->GetBinLowEdge(i), th1->GetBinLowEdge(i+1)), dbn));
+            sumWtot += th1->GetBinContent(i);
+            sumW2tot +=   sumw2s->GetAt(i);
+        }
+    Dbn1D dbn_tot(static_cast<unsigned long>(th1->GetEntries()), sumWtot, sumW2tot, 0, 0);
+
+    Histo1D* rtn =new Histo1D(bins, dbn_tot, dbn_uflow, dbn_oflow,std::string("/")+fname+std::string("/")+th1->GetName(), th1->GetTitle());
+    rtn->setAnnotation("XLabel", th1->GetXaxis()->GetTitle());
+    rtn->setAnnotation("YLabel", th1->GetYaxis()->GetTitle());
+    rtn->setAnnotation("Title", std::string("/")+th1->GetTitle());
+    return rtn;
+}
+
+Scatter2D* TH1toScatter2D(const TH1* th1, std::string fname)
+{
+    Scatter2D* rtn = new Scatter2D(std::string("/")+fname+std::string("/")+th1->GetName());
+    for (int i = 1; i <= th1->GetNbinsX(); ++i)
+        {
+            const double x = th1->GetBinCenter(i);
+            const double exminus = x - th1->GetBinLowEdge(i);
+            const double explus = th1->GetBinLowEdge(i+1) - x;
+            const double width = exminus + explus;
+            rtn->addPoint(x, th1->GetBinContent(i)/width,
+                          exminus, explus,
+                          th1->GetBinErrorLow(i)/width, th1->GetBinErrorUp(i)/width);
+        }
+    rtn->setAnnotation("XLabel", th1->GetXaxis()->GetTitle());
+    rtn->setAnnotation("YLabel", th1->GetYaxis()->GetTitle());
+    rtn->setAnnotation("Title", std::string("/")+th1->GetTitle());
+    return rtn;
+}
+
+
+
+
+Profile1D*         TProfiletoProfile1D(const TProfile* p, std::string fname)
+{
+
+
+    Profile1D* rtn = new Profile1D(std::string("/")+fname+std::string("/")+p->GetName());
+    for (int i = 1; i <= p->GetNbinsX(); ++i)
+        {
+            const double x = p->GetBinCenter(i);
+            const double exminus = x - p->GetBinLowEdge(i);
+            const double explus = p->GetBinLowEdge(i+1) - x;
+            const double width = exminus + explus;
+//FIXME      rtn->addPoint(x, p->GetBinContent(i)/width, exminus, explus,  p->GetBinErrorLow(i)/width, p->GetBinErrorUp(i)/width);
+        }
+    rtn->setAnnotation("XLabel", p->GetXaxis()->GetTitle());
+    rtn->setAnnotation("YLabel", p->GetYaxis()->GetTitle());
+    rtn->setAnnotation("Title", std::string("/")+p->GetTitle());
+    return rtn;
+
+}
+
+
+Scatter2D* TGraphtoScatter2D(const TGraph* g, std::string fname)
+{
+    Scatter2D* rtn = new Scatter2D(std::string("/")+fname+std::string("/")+g->GetName());
+    int i;
+    for (i=0; i<g->GetN()-1; i++)
+        {
+            double x,y;
+            g->GetPoint(i,x,y);
+            rtn->addPoint(x, y,
+                          g->GetErrorXlow(i),
+                          g->GetErrorXhigh(i),
+                          g->GetErrorYlow(i),
+                          g->GetErrorYhigh(i)
+                         );
+        }
+    rtn->addAnnotation("XLabel", g->GetXaxis()->GetTitle());
+    rtn->addAnnotation("YLabel", g->GetYaxis()->GetTitle());
+    rtn->setAnnotation("Title", std::string("/")+g->GetTitle());
+    return rtn;
+}
+
+
+
+TH1D* Histo1DtoTH1D(const Histo1D* h)
+{
+    // Work out bin edges first
+    std::vector<double> edges;
+    edges.reserve(h->numBins()+1);
+    edges.push_back(h->bin(0).xMin());
+    for (size_t i = 0; i < h->numBins(); ++i)
+        {
+            const HistoBin1D& b = h->bin(i);
+            if (!fuzzyEquals(edges.back(), b.xMin())) edges.push_back(b.xMin());
+            if (!fuzzyEquals(edges.back(), b.xMax())) edges.push_back(b.xMax());
+        }
+    // Book ROOT histogram
+    TH1D* rtn= new TH1D(h->path().c_str(), h->title().c_str(), edges.size()-1, &edges[0]);
+    rtn->Sumw2();
+    TArrayD* sumw2s = new TArrayD(*(rtn->GetSumw2()));
+    for (int i = 1; i <= rtn->GetNbinsX(); ++i)
+        {
+            try
+                {
+                    const HistoBin1D& b = h->binAt(rtn->GetBinCenter(i)); // throws if in a gap
+                    rtn->SetBinContent(i, b.sumW());
+                    //FIXME sumw2s[i] = b.sumW2();
+                }
+            catch (const Exception& e) {  }
+        }
+    // Overflows
+    rtn->SetBinContent(0, h->underflow().sumW());
+    rtn->SetBinContent(rtn->GetNbinsX()+1, h->overflow().sumW());
+    //FIXME  sumw2s[0] = h->underflow().sumW2();
+    //FIXME  sumw2s[rtn->GetNbinsX()+1] = h->overflow().sumW2();
+    // Labels
+    if (h->hasAnnotation("XLabel")) rtn->SetXTitle(h->annotation("XLabel").c_str());
+    if (h->hasAnnotation("YLabel")) rtn->SetYTitle(h->annotation("YLabel").c_str());
+
+    return rtn;
+}
+
+
+TProfile* Profile1DtoTProfile(const Profile1D* p)
+{
+    // Work out bin edges first
+    std::vector<double> edges;
+    edges.reserve(p->numBins()+1);
+    edges.push_back(p->bin(0).xMin());
+    for (size_t i = 0; i < p->numBins(); ++i)
+        {
+            const ProfileBin1D& b = p->bin(i);
+            if (!fuzzyEquals(edges.back(), b.xMin())) edges.push_back(b.xMin());
+            if (!fuzzyEquals(edges.back(), b.xMax())) edges.push_back(b.xMax());
+        }
+    // Book ROOT histogram
+    TProfile *rtn =new TProfile(p->path().c_str(), p->title().c_str(), edges.size()-1, &edges[0]);
+    rtn->Sumw2();
+    TArrayD* sumw2s = new TArrayD(*(rtn->GetSumw2()));
+    for (int i = 1; i <= rtn->GetNbinsX(); ++i)
+        {
+            try
+                {
+                    const ProfileBin1D& b = p->binAt(rtn->GetBinCenter(i)); // throws if in a gap
+                    /// @todo This part is probably wrong -- also need to do something with GetW,
+                    ///   GetW2, GetB, GetB2, and/or GetBinSumw2? ROOT docs are 100% useless...
+                    rtn->SetBinContent(i, b.sumW());
+                    //FIXME  sumw2s[i] = b.sumW2();
+                }
+            catch (const Exception& e) {  }
+        }
+    // Overflows
+    rtn->SetBinContent(0, p->underflow().sumW());
+    rtn->SetBinContent(rtn->GetNbinsX()+1, p->overflow().sumW());
+    //FIXME  sumw2s[0] = p->underflow().sumW2();
+    //FIXME  sumw2s[rtn->GetNbinsX()+1] = p->overflow().sumW2();
+    // Labels
+    if (p->hasAnnotation("XLabel")) rtn->SetXTitle(p->annotation("XLabel").c_str());
+    if (p->hasAnnotation("YLabel")) rtn->SetYTitle(p->annotation("YLabel").c_str());
+    return rtn;
+}
+
+
+
+TGraphAsymmErrors* Scatter2DtoTGraphAsymmErrors(const Scatter2D* s)
+{
+    TVectorF xs(s->numPoints()), ys(s->numPoints());
+    TVectorF exls(s->numPoints()), exhs(s->numPoints());
+    TVectorF eyls(s->numPoints()), eyhs(s->numPoints());
+    for (size_t i = 0; i < s->numPoints(); ++i)
+        {
+            const Point2D& p = s->point(i);
+            xs[i] = p.x();
+            ys[i] = p.y();
+            exls[i] = p.xErrMinus();
+            exhs[i] = p.xErrPlus();
+            eyls[i] = p.yErrMinus();
+            eyhs[i] = p.yErrPlus();
+        }
+    // Make the ROOT object... mm, the constructors don't take name+title, unlike all this histos!
+    TGraphAsymmErrors* rtn= new TGraphAsymmErrors(xs, ys, exls, exhs, eyls, eyhs);
+    rtn->SetName(s->path().c_str());
+    rtn->SetTitle(s->title().c_str());
+    // Labels
+    if (s->hasAnnotation("XLabel")) rtn->GetXaxis()->SetTitle(s->annotation("XLabel").c_str());
+    if (s->hasAnnotation("YLabel")) rtn->GetYaxis()->SetTitle(s->annotation("YLabel").c_str());
+    return rtn;
+}
+
+//@}
+
+
+}
+
+#endif
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./src/Writer.cc ./src/Writer.cc
--- ./src/Writer.cc	2014-12-08 20:35:33.118526042 +0200
+++ ./src/Writer.cc	2014-12-08 20:35:33.240524501 +0200
@@ -7,6 +7,9 @@
 #include "YODA/WriterYODA.h"
 #include "YODA/WriterAIDA.h"
 #include "YODA/WriterFLAT.h"
+#ifdef ENABLE_ROOT
+#include "YODA/WriterROOT.h"
+#endif
 #include "boost/algorithm/string.hpp"
 #include <iostream>
 #include <typeinfo>
@@ -23,7 +26,10 @@
     // cout << "File extension: " << fmt << endl;
     if (fmt == "yoda") return WriterYODA::create();
     if (fmt == "aida") return WriterAIDA::create();
-    if (fmt == "dat" || fmt == "flat") return WriterFLAT::create();
+    if (fmt == "flat") return WriterFLAT::create();
+#ifdef ENABLE_ROOT
+    if (fmt == "root") return WriterROOT::create(name);
+#endif
     throw UserError("Format cannot be identified from string '" + name + "'");
   }
 
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./src/WriterROOT.cc ./src/WriterROOT.cc
--- ./src/WriterROOT.cc	1970-01-01 03:00:00.000000000 +0300
+++ ./src/WriterROOT.cc	2014-12-08 20:35:33.240524501 +0200
@@ -0,0 +1,69 @@
+// -*- C++ -*-
+//
+// This file is part of YODA -- Yet more Objects for Data Analysis
+// Copyright (C) 2008-2013 The YODA collaboration (see AUTHORS for details)
+//
+#include "YODA/WriterROOT.h"
+
+#include "YODA/Histo1D.h"
+#include "YODA/Histo2D.h"
+#include "YODA/Profile1D.h"
+#include "YODA/Scatter2D.h"
+#include "YODA/ROOTConvert.h"
+#include <iostream>
+#include <iomanip>
+
+using namespace std;
+
+namespace YODA
+{
+
+
+void WriterROOT::writeHeader(std::ostream& os) {}
+void WriterROOT::writeFooter(std::ostream& os) {}
+void WriterROOT::_writeAnnotations(std::ostream& os, const AnalysisObject& ao) { }
+void WriterROOT::writeCounter(std::ostream& os, const Counter& c) { }
+
+void WriterROOT::writeHisto1D(std::ostream& os, const Histo1D& h)
+{
+    if (_ROOTfile) _ROOTfile->cd();
+    else printf("No output ROOT file %s\n",_filename.c_str());
+    TH1D* dps=YODA::Histo1DtoTH1D(&h);
+    if (dps) {  dps->SetDirectory(_ROOTfile); dps->Write( ); dps->SetDirectory(0);}
+}
+
+
+void WriterROOT::writeHisto2D(std::ostream& os, const Histo2D& h) { }
+
+void WriterROOT::writeProfile1D(std::ostream& os, const Profile1D& p)
+{
+    if (_ROOTfile) _ROOTfile->cd();
+    else printf("No output ROOT file %s\n",_filename.c_str());
+    TProfile* dps=YODA::Profile1DtoTProfile(&p);
+    if (dps) { dps->SetDirectory(_ROOTfile); dps->Write(); dps->SetDirectory(0);}
+}
+
+void WriterROOT::writeScatter2D(std::ostream& os, const Scatter2D& s)
+{
+    if (_ROOTfile) _ROOTfile->cd();
+    else printf("No output ROOT file %s\n",_filename.c_str());
+    TGraphAsymmErrors* dps=YODA::Scatter2DtoTGraphAsymmErrors(&s);
+    if (dps)
+        {
+            _ROOTfile->Append(dps),  dps->Write();
+            //dps->SetDirectory(0);
+        }
+    //dps->SetDirectory(0);
+}
+
+
+     void WriterROOT::writeProfile2D(std::ostream& stream, const Profile2D& p){};
+    void WriterROOT::writeScatter1D(std::ostream& stream, const Scatter1D& s){};
+
+     void WriterROOT::writeScatter3D(std::ostream& stream, const Scatter3D& s){};
+
+
+
+
+
+}
