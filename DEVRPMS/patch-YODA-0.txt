diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./include/YODA/Makefile.am ./include/YODA/Makefile.am
--- ./include/YODA/Makefile.am	2015-05-20 15:08:18.901370723 +0200
+++ ./include/YODA/Makefile.am	2015-05-20 15:08:19.805396185 +0200
@@ -16,7 +16,11 @@
     ScatterND.h PointND.h ErrorND.h \
     Writer.h WriterAIDA.h WriterFLAT.h WriterYODA.h \
     Reader.h ReaderAIDA.h ReaderYODA.h ReaderFLAT.h \
-    YODA.h IO.h ROOTCnv.h
+    IO.h ROOTCnv.h
+
+if  ENABLE_ROOT
+pkginclude_HEADERS+=WriterROOT.h ReaderROOT.h ROOTConvert.h
+endif
 
 nobase_pkginclude_HEADERS = \
 	WriterMethods.icc \
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./include/YODA/ReaderROOT.h ./include/YODA/ReaderROOT.h
--- ./include/YODA/ReaderROOT.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/YODA/ReaderROOT.h	2015-05-20 15:08:19.805396185 +0200
@@ -0,0 +1,75 @@
+// -*- C++ -*-
+//
+// This file is part of YODA -- Yet more Objects for Data Analysis
+//Andrii Verbytskyi, 2014
+//
+#ifndef YODA_READERROOT_H
+#define YODA_READERROOT_H
+
+#include "YODA/AnalysisObject.h"
+#include "YODA/Reader.h"
+#include "YODA/ROOTConvert.h"
+#include <YODA/Scatter2D.h>
+#include <boost/spirit/include/qi.hpp>
+#include <boost/spirit/include/phoenix_operator.hpp>
+#include <boost/fusion/include/adapt_struct.hpp>
+
+
+namespace YODA {
+
+  using namespace boost::spirit;
+  using namespace boost::phoenix;
+
+
+  /// Persistency reader from YODA flat text data format.
+  class ReaderROOT : public Reader {
+  public:
+
+    /// Singleton creation function
+    static Reader& create() {
+      static ReaderROOT _instance;
+      return _instance;
+    }
+
+    static Reader& create(std::string filename) {
+      static ReaderROOT _instance(filename);      
+      return _instance;
+    }
+
+
+    void read(std::istream& stream, std::vector<AnalysisObject*>& aos) {
+      _readDoc(stream, aos);
+    }
+
+
+
+    // Hide from Doxygen until endcond
+    /// @cond
+
+
+  protected:
+
+    void _readDoc(std::istream& stream, std::vector<AnalysisObject*>& aos);
+
+
+  private:
+std::string _filename;
+
+
+  public:
+
+    /// Private constructor, since it's a singleton.
+    /// @todo This is definitely not private!
+
+    ReaderROOT() { }
+    ReaderROOT(std::string filename) {_filename=filename;}
+
+  
+};
+
+} // end of YODA namespace
+
+
+/// @endcond
+
+#endif
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./include/YODA/ROOTCnv.h ./include/YODA/ROOTCnv.h
--- ./include/YODA/ROOTCnv.h	2015-05-20 15:08:18.889370385 +0200
+++ ./include/YODA/ROOTCnv.h	2015-05-20 15:08:19.801396072 +0200
@@ -1,7 +1,7 @@
 // -*- C++ -*-
 //
 // This file is part of YODA -- Yet more Objects for Data Analysis
-// Copyright (C) 2008-2015 The YODA collaboration (see AUTHORS for details)
+// Copyright (C) 2008-2014 The YODA collaboration (see AUTHORS for details)
 //
 #ifndef YODA_ROOTCnv_h
 #define YODA_ROOTCnv_h
@@ -140,61 +140,6 @@
   }
 
 
-
-  /// @brief Convert a YODA Histo2D to a ROOT 2D histogram
-  ///
-  /// @todo Check/improve/extend -- needs SetBinError or not?
-  inline TH2D toTH2D(const Histo2D& h) {
-    // Work out bin edges first
-    std::vector<double> xedges, yedges;
-    xedges.reserve(h.numBins()+1);
-    yedges.reserve(h.numBins()+1);
-    xedges.push_back(h.bin(0).xMin());
-    yedges.push_back(h.bin(0).yMin());
-    for (size_t i = 0; i < h.numBins(); ++i) {
-      const HistoBin2D& b = h.bin(i);
-      xedges.push_back(b.xMin());
-      xedges.push_back(b.xMax());
-      yedges.push_back(b.yMin());
-      yedges.push_back(b.yMax());
-    }
-    // Sort and remove (fuzzy) duplicate edges
-    std::sort(xedges.begin(), xedges.end());
-    std::sort(yedges.begin(), yedges.end());
-    const std::vector<double>::iterator xlast = std::unique(xedges.begin(), xedges.end());
-    const std::vector<double>::iterator ylast = std::unique(yedges.begin(), yedges.end());
-    xedges.erase(xlast, xedges.end());
-    yedges.erase(ylast, yedges.end());
-
-    // Book ROOT histogram
-    TH2D rtn(h.path().c_str(), h.title().c_str(), xedges.size()-1, &xedges[0], yedges.size()-1, &yedges[0]);
-    rtn.Sumw2();
-    TArrayD& sumw2s = *rtn.GetSumw2();
-    for (int ix = 1; ix <= rtn.GetNbinsX(); ++ix) {
-      for (int iy = 1; iy <= rtn.GetNbinsY(); ++iy) {
-        const int i = rtn.GetBin(ix, iy);
-        try {
-          const HistoBin2D& b = h.binAt(rtn.GetBinCenter(ix), rtn.GetBinCenter(iy)); // throws if in a gap
-          rtn.SetBinContent(i, b.sumW());
-          sumw2s[i] = b.sumW2();
-        } catch (const Exception& e) {  }
-      }
-    }
-    // Overflows
-    /// @todo Connect up when supported in YODA... if 2D overflows are possible in ROOT?!
-    // rtn.SetBinContent(0, h.underflow().sumW());
-    // rtn.SetBinContent(rtn.GetNbinsX()+1, h.overflow().sumW());
-    // sumw2s[0] = h.underflow().sumW2();
-    // sumw2s[rtn.GetNbinsX()+1] = h.overflow().sumW2();
-    // Labels
-    if (h.hasAnnotation("XLabel")) rtn.SetXTitle(h.annotation("XLabel").c_str());
-    if (h.hasAnnotation("YLabel")) rtn.SetYTitle(h.annotation("YLabel").c_str());
-    if (h.hasAnnotation("ZLabel")) rtn.SetZTitle(h.annotation("ZLabel").c_str());
-    return rtn;
-  }
-
-
-
   /// @brief Convert a YODA Scatter2D to a ROOT TH1D
 
 
@@ -214,62 +159,21 @@
     // Book ROOT histogram
     TProfile rtn(p.path().c_str(), p.title().c_str(), edges.size()-1, &edges[0]);
     rtn.Sumw2();
-    Double_t* sumwys = rtn.GetArray(); //< YUCK!!!
-    TArrayD& sumwy2s = *rtn.GetSumw2(); //< YUCK!!!
-    for (int i = 1; i <= rtn.GetNbinsX(); ++i) {
-      try {
-        const ProfileBin1D& b = p.binAt(rtn.GetBinCenter(i)); // throws if in a gap
-        // rtn.SetBinContent(i, b.mean());
-        // rtn.SetBinError(i, b.stdErr());
-        /// @todo Need to set the following, according to Roman Lysak:
-        // - for sum(y*y): TProfile::GetSumw2()
-        // - for sum(y):   TProfile::GetArray()
-        // - for sum(w):   TProfile::SetBinEntries(bin, w)
-        // Clearly, the names of accessors/methods are confusing...
-        rtn.SetBinEntries(i, b.sumW());
-        sumwys[i] = b.sumWY();
-        sumwy2s[i] = b.sumWY2();
-      } catch (const Exception& e) {  }
-    }
-    // Overflows
-    rtn.SetBinEntries(0, p.underflow().sumW());
-    rtn.SetBinEntries(rtn.GetNbinsX()+1, p.overflow().sumW());
-    sumwys[0] = p.underflow().sumWY();
-    sumwys[0] = p.underflow().sumWY();
-    sumwy2s[rtn.GetNbinsX()+1] = p.overflow().sumWY2();
-    sumwy2s[rtn.GetNbinsX()+1] = p.overflow().sumWY2();
-    // Labels
-    if (p.hasAnnotation("XLabel")) rtn.SetXTitle(p.annotation("XLabel").c_str());
-    if (p.hasAnnotation("YLabel")) rtn.SetYTitle(p.annotation("YLabel").c_str());
-    return rtn;
-  }
-
-
-  /// @brief Convert a YODA Profile1D to a ROOT TH1D
-  inline TH1D toTH1D(const Profile1D& p) {
-    // Work out bin edges first
-    std::vector<double> edges;
-    edges.reserve(p.numBins()+1);
-    edges.push_back(p.bin(0).xMin());
-    for (size_t i = 0; i < p.numBins(); ++i) {
-      const ProfileBin1D& b = p.bin(i);
-      if (!fuzzyEquals(edges.back(), b.xMin())) edges.push_back(b.xMin());
-      if (!fuzzyEquals(edges.back(), b.xMax())) edges.push_back(b.xMax());
-    }
-    // Book ROOT histogram
-    TH1D rtn(p.path().c_str(), p.title().c_str(), edges.size()-1, &edges[0]);
+    TArrayD& sumw2s = *rtn.GetSumw2();
     for (int i = 1; i <= rtn.GetNbinsX(); ++i) {
       try {
         const ProfileBin1D& b = p.binAt(rtn.GetBinCenter(i)); // throws if in a gap
-        rtn.SetBinContent(i, b.mean());
-        rtn.SetBinError(i, b.stdErr());
+        /// @todo This part is probably wrong -- also need to do something with GetW,
+        ///   GetW2, GetB, GetB2, and/or GetBinSumw2? ROOT docs are 100% useless...
+        rtn.SetBinContent(i, b.sumW());
+        sumw2s[i] = b.sumW2();
       } catch (const Exception& e) {  }
     }
     // Overflows
-    rtn.SetBinContent(0, p.underflow().yMean());
-    rtn.SetBinContent(rtn.GetNbinsX()+1, p.overflow().yMean());
-    rtn.SetBinError(0, p.underflow().yStdErr());
-    rtn.SetBinError(rtn.GetNbinsX()+1, p.overflow().yStdErr());
+    rtn.SetBinContent(0, p.underflow().sumW());
+    rtn.SetBinContent(rtn.GetNbinsX()+1, p.overflow().sumW());
+    sumw2s[0] = p.underflow().sumW2();
+    sumw2s[rtn.GetNbinsX()+1] = p.overflow().sumW2();
     // Labels
     if (p.hasAnnotation("XLabel")) rtn.SetXTitle(p.annotation("XLabel").c_str());
     if (p.hasAnnotation("YLabel")) rtn.SetYTitle(p.annotation("YLabel").c_str());
@@ -277,12 +181,6 @@
   }
 
 
-  /// @todo Convert a YODA Profile2D to a ROOT TProfile2D
-
-
-
-
-
   /// @brief Convert a YODA Scatter2D to a ROOT TGraphAsymmErrors
   ///
   /// @todo Check/improve/extend.
@@ -309,24 +207,6 @@
     return rtn;
   }
 
-
-  /// @brief Convert a YODA Histo1D to a ROOT TGraphAsymmErrors
-  ///
-  inline TGraphAsymmErrors toTGraph(const Histo1D& h) {
-    return toTGraph(mkScatter(h));
-  }
-
-
-  /// @brief Convert a YODA Profile1D to a ROOT TGraphAsymmErrors
-  ///
-  inline TGraphAsymmErrors toTGraph(const Profile1D& p) {
-    return toTGraph(mkScatter(p));
-  }
-
-
-  /// @todo Convert YODA Histo2D and Profile2D to TGraph colour maps
-
-
   //@}
 
 
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./include/YODA/ROOTConvert.h ./include/YODA/ROOTConvert.h
--- ./include/YODA/ROOTConvert.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/YODA/ROOTConvert.h	2015-05-20 15:08:19.805396185 +0200
@@ -0,0 +1,36 @@
+// AV 2014
+#ifndef YODA_ROOTConvert_h
+#define YODA_ROOTConvert_h
+
+#include "YODA/Histo1D.h"
+#include "YODA/Histo2D.h"
+#include "YODA/Profile1D.h"
+#include "YODA/Histo1D.h"
+#include "YODA/Profile1D.h"
+#include "YODA/Scatter2D.h"
+#include "TH1.h"
+#include "TH2.h"
+#include "TProfile.h"
+#include "TGraphAsymmErrors.h"
+#include "TVectorF.h"
+#include "TFile.h"
+#include "TList.h"
+#include "TKey.h"
+#include "TClass.h"
+#include "TH1F.h"
+#include <string>
+
+namespace YODA {
+
+Histo1D*           TH1toHisto1D  (const TH1* th1, std::string fname="");
+TH1D*              Histo1DtoTH1D(const Histo1D* h) ;
+
+Profile1D*         TProfiletoProfile1D(const TProfile*  p, std::string fname="") ;
+TProfile*          Profile1DtoTProfile(const Profile1D* p) ;
+
+Scatter2D*         TGraphtoScatter2D(const TGraph* g, std::string fname="") ;
+TGraphAsymmErrors* Scatter2DtoTGraphAsymmErrors(const Scatter2D* s) ;
+
+}
+
+#endif
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./include/YODA/WriterROOT.h ./include/YODA/WriterROOT.h
--- ./include/YODA/WriterROOT.h	1970-01-01 01:00:00.000000000 +0100
+++ ./include/YODA/WriterROOT.h	2015-05-20 15:08:19.801396072 +0200
@@ -0,0 +1,72 @@
+// -*- C++ -*-
+//
+// This file is part of YODA -- Yet more Objects for Data Analysis
+// Copyright (C) 2008-2013 The YODA collaboration (see AUTHORS for details)
+//
+#ifndef YODA_WRITERROOT_H
+#define YODA_WRITERROOT_H
+
+#include "YODA/AnalysisObject.h"
+#include "YODA/Writer.h"
+#include "YODA/ROOTConvert.h"
+#include <vector>
+#include <string>
+#include <ostream>
+
+
+namespace YODA {
+
+
+  /// Persistency writer for flat text format.
+  class WriterROOT : public Writer {
+  public:
+
+    /// Singleton creation function
+    static Writer& create() {
+      static WriterROOT _instance;
+      _instance.setPrecision(6);
+      return _instance;
+    }
+
+    static Writer& create(std::string filename) {
+      static WriterROOT _instance(filename);
+      _instance.setPrecision(6);
+      return _instance;
+    }
+
+
+    // Include definitions of all write methods (all fulfilled by Writer::write(...))
+    #include "YODA/WriterMethods.icc"
+
+
+  protected:
+
+    void writeHeader(std::ostream& stream);
+    //void writeBody(std::ostream& stream, const AnalysisObject& ao);
+    void writeFooter(std::ostream& stream);
+  //void write(const std::string& filename, const AnalysisObject& ao);
+    void writeCounter(std::ostream& stream, const Counter& c);
+    void writeHisto1D(std::ostream& stream, const Histo1D& h);
+    void writeHisto2D(std::ostream& stream, const Histo2D& h);
+    void writeProfile1D(std::ostream& stream, const Profile1D& p);
+     void writeProfile2D(std::ostream& stream, const Profile2D& p);
+    void writeScatter1D(std::ostream& stream, const Scatter1D& s);
+    void writeScatter2D(std::ostream& stream, const Scatter2D& s);
+     void writeScatter3D(std::ostream& stream, const Scatter3D& s);
+
+
+  private:
+std::string _filename;
+TFile* _ROOTfile;
+    void _writeAnnotations(std::ostream& os, const AnalysisObject& ao);
+
+    /// Private since it's a singleton.
+    WriterROOT() { }
+    WriterROOT(std::string filename) {  _filename=filename; _ROOTfile=new TFile(filename.c_str(),"recreate");  }
+     ~WriterROOT() {if (_ROOTfile) _ROOTfile->Close();}
+  };
+
+
+}
+
+#endif
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./pyext/Makefile.am ./pyext/Makefile.am
--- ./pyext/Makefile.am	2015-05-20 15:08:19.725393932 +0200
+++ ./pyext/Makefile.am	2015-05-20 15:08:19.809396298 +0200
@@ -4,7 +4,7 @@
 PYEXT_ENV = CC="$(CC)" CXX="$(CXX)" CXXFLAGS="$(PYEXT_CXXFLAGS)" ARCHFLAGS=""
 
 if ENABLE_ROOT
-  PYEXT_ENV += BUILD_ROOTCOMPAT="yes"
+  PYEXT_ENV = CC="$(CXX)" CXX="$(CXX)" CXXFLAGS="$(PYEXT_CXXFLAGS) $(ROOT_CXXFLAGS) -Wno-long-long  -DENABLE_ROOT" CFLAGS="$(PYEXT_CFLAGS) $(ROOT_CXXFLAGS) -Wno-long-long  -DENABLE_ROOT" ARCHFLAGS="" BUILD_ROOTCOMPAT="yes"
 endif
 
 ## Always force setup.py, it's not good at guessing what needs to rebuild
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./pyext/yoda/declarations.pxd ./pyext/yoda/declarations.pxd
--- ./pyext/yoda/declarations.pxd	2015-05-20 15:08:19.777395398 +0200
+++ ./pyext/yoda/declarations.pxd	2015-05-20 15:08:19.813396412 +0200
@@ -359,8 +359,8 @@
 
         #We're fine as long as we don't try to instantiate these from Python
 
-        # void scaleW(double scale) except +yodaerr
-        # void scaleX(double scale) except +yodaerr
+        void scaleW(double scale) except +yodaerr
+        void scaleX(double scale) except +yodaerr
         void reset()  except +yodaerr
 
         pair[double, double] edges() except +yodaerr
@@ -407,8 +407,8 @@
         Bin2D() # (DO NOT CALL DO NOT CALL)
         ################################################
 
-        # void scaleW(double scale) except +yodaerr
-        # void scaleXY(double, double) except +yodaerr
+        void scaleW(double scale) except +yodaerr
+        void scaleXY(double, double) except +yodaerr
         void reset()  except +yodaerr
 
         pair[double, double] xEdges() except +yodaerr
@@ -470,8 +470,8 @@
     cdef cppclass ProfileBin1D(Bin1D_Dbn2D):
         ProfileBin1D(ProfileBin1D) except +yodaerr
         ProfileBin1D(double, double) except +yodaerr
-        #void fill(double x, double y, double weight) except +yodaerr
-        #void fillBin(double y, double weight) except +yodaerr
+        void fill(double x, double y, double weight) except +yodaerr
+        void fillBin(double y, double weight) except +yodaerr
         void reset() except +yodaerr
 
         double mean() except +yodaerr
@@ -485,7 +485,8 @@
         ProfileBin1D operator + (ProfileBin1D) except +yodaerr
         ProfileBin1D operator - (ProfileBin1D) except +yodaerr
 
-        # void scaleY(double) except +yodaerr
+        void scaleY(double) except +yodaerr
+        void scaleXY(double) except +yodaerr
 
 # }}} ProfileBin1D
 
@@ -505,8 +506,8 @@
     cdef cppclass ProfileBin2D(Bin2D_Dbn3D):
         ProfileBin2D (ProfileBin2D h) except +yodaerr
         ProfileBin2D (double, double, double, double) except +yodaerr
-        # void fill(double x, double y, double z, double weight) except +yodaerr
-        # void fillBin(double z, double weight) except +yodaerr
+        void fill(double x, double y, double z, double weight) except +yodaerr
+        void fillBin(double z, double weight) except +yodaerr
 
         double mean() except +yodaerr
         double stdDev() except +yodaerr
@@ -519,8 +520,6 @@
         ProfileBin2D operator + (ProfileBin2D) except +yodaerr
         ProfileBin2D operator - (ProfileBin2D) except +yodaerr
 
-        # void scaleZ(double) except +yodaerr
-
 # }}} ProfileBin2D
 
 
@@ -529,8 +528,8 @@
     cdef cppclass HistoBin1D(Bin1D_Dbn1D):
         HistoBin1D(double lowedge, double highedge) except +yodaerr
         HistoBin1D(HistoBin1D) except +yodaerr
-        # void fill(double x, double weight) except +yodaerr
-        # void fillBin(double weight) except +yodaerr
+        void fill(double x, double weight) except +yodaerr
+        void fillBin(double weight) except +yodaerr
 
         double area() except +yodaerr
         double height() except +yodaerr
@@ -559,8 +558,8 @@
         HistoBin2D(double xmin, double xmax, double ymin, double ymax) except +yodaerr
         HistoBin2D(HistoBin2D) except +yodaerr
 
-        # void fill(double x, double y, double weight) except +yodaerr
-        # void fillBin(double weight) except +yodaerr
+        void fill(double x, double y, double weight) except +yodaerr
+        void fillBin(double weight) except +yodaerr
         void reset()
 
         # Accessors
@@ -864,8 +863,6 @@
         void fillBin(size_t i, double y, double weight) except +yodaerr
 
         void scaleW(double s) except +yodaerr
-        void scaleY(double s) except +yodaerr
-
         void mergeBins(size_t, size_t) except +yodaerr
         void rebin(int n) except +yodaerr
 
@@ -910,7 +907,7 @@
     Profile1D* Profile1D_div_Profile1D "cython_div" (Profile1D*, Profile1D*)
 
 cdef extern from "YODA/Scatter2D.h" namespace "YODA":
-    Scatter2D mkScatter_Profile1D "YODA::mkScatter" (const Profile1D&, bool) except +yodaerr
+    Scatter2D mkScatter_Profile1D "YODA::mkScatter" (const Profile1D&) except +yodaerr
 
 #}}} Profile1D
 
@@ -995,7 +992,7 @@
     Profile2D* Profile2D_div_Profile2D "cython_div" (Profile2D*, Profile2D*)
 
 cdef extern from "YODA/Scatter3D.h" namespace "YODA":
-    Scatter3D mkScatter_Profile2D "YODA::mkScatter" (const Profile2D&, bool) except +yodaerr
+    Scatter3D mkScatter_Profile2D "YODA::mkScatter" (const Profile2D&) except +yodaerr
 
 #}}} Profile2D
 
@@ -1091,7 +1088,7 @@
     Histo1D* Histo1D_div_Histo1D "cython_div" (Histo1D*, Histo1D*)
 
 cdef extern from "YODA/Scatter2D.h" namespace "YODA":
-    Scatter2D mkScatter_Histo1D "YODA::mkScatter" (const Histo1D&, bool) except +yodaerr
+    Scatter2D mkScatter_Histo1D "YODA::mkScatter" (const Histo1D&) except +yodaerr
 
 #}}} Histo1D
 
@@ -1138,7 +1135,7 @@
         size_t numBinsX() except +yodaerr
         size_t numBinsY() except +yodaerr
 
-        vector[HistoBin2D]& bins() #except +yodaerr
+        vector[HistoBin1D]& bins() #except +yodaerr
         int binIndexAt(double x, double y) except +yodaerr
         HistoBin2D& bin(size_t ix) #except +yodaerr
         HistoBin2D& binAt(double x, double y) #except +yodaerr
@@ -1191,7 +1188,7 @@
     Histo2D* Histo2D_div_Histo2D "cython_div" (Histo2D*, Histo2D*)
 
 cdef extern from "YODA/Scatter3D.h" namespace "YODA":
-    Scatter3D mkScatter_Histo2D "YODA::mkScatter" (const Histo2D&, bool) except +yodaerr
+    Scatter3D mkScatter_Histo2D "YODA::mkScatter" (const Histo2D&) except +yodaerr
 
 # Histo2D }}}
 
@@ -1220,6 +1217,9 @@
 cdef extern from "YODA/ReaderFLAT.h" namespace "YODA":
     Reader& ReaderFLAT_create "YODA::ReaderFLAT::create" ()
 
+cdef extern from "YODA/ReaderROOT.h" namespace "YODA":
+    Reader& ReaderROOT_create "YODA::ReaderROOT::create" ()
+
 cdef extern from "YODA/ReaderAIDA.h" namespace "YODA":
     Reader& ReaderAIDA_create "YODA::ReaderAIDA::create" ()
 
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./pyext/yoda/Makefile.am ./pyext/yoda/Makefile.am
--- ./pyext/yoda/Makefile.am	2015-05-20 15:08:19.729394045 +0200
+++ ./pyext/yoda/Makefile.am	2015-05-20 15:08:19.809396298 +0200
@@ -4,7 +4,6 @@
     errors.cpp errors.hh \
     pyroot_helpers.hh merge.hh \
     rootcompat.pxd rootcompat.pyx \
-    search.py plotting.py \
     script_helpers.py
 
 CYTHON_SRC = \
@@ -41,14 +40,20 @@
     include/Scatter2D.pyx \
     include/Scatter3D.pyx
 
+
 EXTRA_DIST += \
     $(CYTHON_SRC) \
     mktemplates \
     core.cpp core.h util.cpp
 
+if ENABLE_ROOT
+  CXXFLAGS += $(ROOT_CXXFLAGS) -Wno-long-long 
+endif
+
 
 if WITH_CYTHON
-core.cpp core.h: $(CYTHON_SRC) .made_pyx_templates
+core.cpp core.h: $(CYTHON_SRC)
+	./mktemplates
 	cython core.pyx --cplus
 else
 core.cpp core.h: $(CYTHON_SRC)
@@ -57,7 +62,8 @@
 
 
 if WITH_CYTHON
-util.cpp: util.pxd util.pyx .made_pyx_templates
+util.cpp: util.pxd util.pyx
+	./mktemplates
 	cython util.pyx --cplus
 else
 util.cpp: util.pxd util.pyx
@@ -72,7 +78,8 @@
 	@true
 
 if WITH_CYTHON
-rootcompat.cpp: util.pxd rootcompat.pxd rootcompat.pyx .made_pyx_templates
+rootcompat.cpp: util.pxd rootcompat.pxd rootcompat.pyx
+	./mktemplates
 	cython rootcompat.pyx --cplus
 else
 rootcompat.cpp: util.pxd rootcompat.pxd rootcompat.pyx
@@ -80,10 +87,6 @@
 endif
 
 
-## Make text-substitution .pyx files from templates -- should only run once
-.made_pyx_templates: include/Bin1D_DBN.pyx include/Bin2D_DBN.pyx include/Axis1D_BIN1D_DBN.pyx include/Axis2D_BIN2D_DBN.pyx
-	./mktemplates
-	touch $@
 
 
 ## fixes for out-of-source builds, especially "make distcheck"
@@ -109,4 +112,4 @@
 	rm -f $<
 
 distclean-local:
-	rm -f core.cpp core.h util.cpp rootcompat.cpp include/generated/* .made_pyx_templates
+	rm -f core.cpp core.h util.cpp rootcompat.cpp include/generated/*
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./pyext/yoda/mktemplates ./pyext/yoda/mktemplates
--- ./pyext/yoda/mktemplates	2015-05-20 15:08:19.781395510 +0200
+++ ./pyext/yoda/mktemplates	2015-05-20 15:08:19.817396524 +0200
@@ -52,8 +52,9 @@
     try:
         os.mkdir("include/generated")
     except OSError as exc: # Python >2.5
-        if exc.errno != errno.EEXIST or not os.path.isdir("include/generated"):
-            raise
+        if exc.errno == errno.EEXIST and os.path.isdir("include/generated"):
+            pass
+        else: raise
 
     includes = []
     for a in individuals:
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./pyext/yoda/rootcompat.pxd ./pyext/yoda/rootcompat.pxd
--- ./pyext/yoda/rootcompat.pxd	2015-05-20 15:08:19.781395510 +0200
+++ ./pyext/yoda/rootcompat.pxd	2015-05-20 15:08:19.813396412 +0200
@@ -28,8 +28,8 @@
 cdef extern from "pyroot_helpers.hh":
     cpython.PyObject* root_to_py_owned(TObject* root_obj)
 
-cdef extern from "YODA/ROOTCnv.h" namespace "YODA":
-    Scatter2D toScatter2D(TH1*)
-    TH1D toTH1D(Histo1D)
-    TProfile toTProfile(Profile1D)
-    TGraphAsymmErrors toTGraph(Scatter2D)
+#cdef extern from "YODA/ROOTCnv.h" namespace "YODA":
+#    Scatter2D toScatter2D(TH1*)
+#    TH1D toTH1D(Histo1D)
+#    TProfile toTProfile(Profile1D)
+#    TGraphAsymmErrors toTGraph(Scatter2D)
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./pyext/yoda/rootcompat.pyx ./pyext/yoda/rootcompat.pyx
--- ./pyext/yoda/rootcompat.pyx	2015-05-20 15:08:19.777395398 +0200
+++ ./pyext/yoda/rootcompat.pyx	2015-05-20 15:08:19.813396412 +0200
@@ -24,26 +24,27 @@
 
     cdef void *ptr = yoda_obj.ptr()
 
-    if isinstance(yoda_obj, yoda.Histo1D):
-        return _toTH1D(<cyoda.Histo1D*> ptr)
+    return <object> ptr
+#    if isinstance(yoda_obj, yoda.Histo1D):
+#        return _toTH1D(<cyoda.Histo1D*> ptr)
 
-    elif isinstance(yoda_obj, yoda.Profile1D):
-        return _toTProfile(<cyoda.Profile1D*> ptr)
+#    elif isinstance(yoda_obj, yoda.Profile1D):
+#        return _toTProfile(<cyoda.Profile1D*> ptr)
 
-    elif isinstance(yoda_obj, yoda.Scatter2D):
-        return _toTGraph(<cyoda.Scatter2D*> ptr)
+#    elif isinstance(yoda_obj, yoda.Scatter2D):
+#        return _toTGraph(<cyoda.Scatter2D*> ptr)
 
 cdef object root_to_py(c.TObject* tobj):
     return <object> c.root_to_py_owned(tobj)
 
-cdef _toTH1D(cyoda.Histo1D* h1d):
-    return ROOT.TH1D(
-        root_to_py(new c.TH1D(c.toTH1D(deref(h1d)))))
-
-cdef _toTProfile(cyoda.Profile1D* p1d):
-    return ROOT.TProfile(
-        root_to_py(new c.TProfile(c.toTProfile(deref(p1d)))))
-
-cdef _toTGraph(cyoda.Scatter2D* s2d):
-    return ROOT.TGraphAsymmErrors(
-        root_to_py(new c.TGraphAsymmErrors(c.toTGraph(deref(s2d)))))
+#cdef _toTH1D(cyoda.Histo1D* h1d):
+#    return ROOT.TH1D(
+#        root_to_py(new c.TH1D(c.toTH1D(deref(h1d)))))
+
+#cdef _toTProfile(cyoda.Profile1D* p1d):
+#    return ROOT.TProfile(
+#        root_to_py(new c.TProfile(c.toTProfile(deref(p1d)))))
+
+#cdef _toTGraph(cyoda.Scatter2D* s2d):
+#    return ROOT.TGraphAsymmErrors(
+#        root_to_py(new c.TGraphAsymmErrors(c.toTGraph(deref(s2d)))))
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./src/Makefile.am ./src/Makefile.am
--- ./src/Makefile.am	2015-05-20 15:08:18.985373089 +0200
+++ ./src/Makefile.am	2015-05-20 15:08:19.821396636 +0200
@@ -27,3 +27,13 @@
 libYODA_la_LDFLAGS = -avoid-version
 libYODA_la_LIBADD = tinyxml/libtinyxml.la
 libYODA_la_CPPFLAGS = $(AM_CPPFLAGS) -DTIXML_USE_STL
+
+if  ENABLE_ROOT
+libYODA_la_SOURCES += ROOTConvert.cc 
+libYODA_la_SOURCES += ReaderROOT.cc 
+libYODA_la_SOURCES += WriterROOT.cc 
+libYODA_la_LDFLAGS += $(ROOT_LDFLAGS) $(ROOT_LIBS)
+libYODA_la_CPPFLAGS += $(ROOT_CXXFLAGS) -Wno-long-long 
+#libYODA_la_CXXFLAGS += $(ROOT_CXXFLAGS) -Wno-long-long 
+
+endif
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./src/Reader.cc ./src/Reader.cc
--- ./src/Reader.cc	2015-05-20 15:08:18.981372976 +0200
+++ ./src/Reader.cc	2015-05-20 15:08:19.817396524 +0200
@@ -1,10 +1,13 @@
 // -*- C++ -*-
 //
 // This file is part of YODA -- Yet more Objects for Data Analysis
-// Copyright (C) 2008-2015 The YODA collaboration (see AUTHORS for details)
+// Copyright (C) 2008-2014 The YODA collaboration (see AUTHORS for details)
 //
 #include "YODA/Reader.h"
 #include "YODA/ReaderYODA.h"
+#ifdef ENABLE_ROOT
+#include "YODA/ReaderROOT.h"
+#endif
 #include "YODA/ReaderAIDA.h"
 #include "YODA/ReaderFLAT.h"
 
@@ -20,6 +23,9 @@
     if (fmt == "yoda") return ReaderYODA::create();
     if (fmt == "aida") return ReaderAIDA::create();
     if (fmt == "dat" || fmt == "flat")  return ReaderFLAT::create();
+#ifdef ENABLE_ROOT
+    if (fmt == "root") return ReaderROOT::create(name);
+#endif
     throw UserError("Format cannot be identified from string '" + name + "'");
   }
 
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./src/ReaderROOT.cc ./src/ReaderROOT.cc
--- ./src/ReaderROOT.cc	1970-01-01 01:00:00.000000000 +0100
+++ ./src/ReaderROOT.cc	2015-05-20 15:08:19.821396636 +0200
@@ -0,0 +1,85 @@
+// -*- C++ -*-
+//
+// This file is part of YODA -- Yet more Objects for Data Analysis
+// Copyright (C) 2008-2013 The YODA collaboration (see AUTHORS for details)
+//
+
+#include "YODA/ReaderROOT.h"
+#include "YODA/Utils/StringUtils.h"
+#include "YODA/Exceptions.h"
+#include <iostream>
+
+
+
+using namespace std;
+
+namespace YODA
+{
+
+void ReaderROOT::_readDoc(std::istream& stream, vector<AnalysisObject*>& aos)
+{
+    std::string streama=_filename; //Ugly trick;
+    TFile* fin = new TFile(streama.c_str()) ;
+    if (!fin->IsOpen())
+        {
+            printf("Cannot open input file %s\n",streama.c_str()) ;
+            exit(1) ;
+        }
+
+    TList* list = fin->GetListOfKeys() ;
+    if (!list) { printf("No keys found in file %s\n",streama.c_str()) ; exit(1) ; }
+
+    TIter next(list) ;
+    TKey* key ;
+    TObject* obj ;
+
+    while ( key = (TKey*)next() )
+        {
+            obj = key->ReadObj() ;
+            int type=-1;
+
+            if (strcmp(obj->IsA()->GetName(),"TProfile")==0) type=0;
+            if (strcmp(obj->IsA()->GetName(),"TH1F")==0)type=11;
+            if (strcmp(obj->IsA()->GetName(),"TH1D")==0) type=12;
+            if (obj->InheritsFrom("TH2")) type=2;
+            if (strcmp(obj->IsA()->GetName(),"TGraph")==0)type=31;
+            if (strcmp(obj->IsA()->GetName(),"TGraphErrors")==0) type=32;
+            if (strcmp(obj->IsA()->GetName(),"TGraphAsymmErrors")==0)type=33;
+            if (type==-1)  printf("Object %s  has unsupported type %s and will not be converted\n",obj->GetName(),obj->IsA()->GetName()) ;
+            if (type==0)
+                {
+                    TProfile* P= (TProfile*)(obj);
+                    YODA::Profile1D* dps = TProfiletoProfile1D(P,_filename);
+                    aos.push_back(dps);
+                }
+            if (type==11||type==12)
+                {
+                    /*
+                    The mapping is TH? <-> Histo?D, TProfile <-> Profile1D, TGraph <-> Scatter2D.
+                    */
+
+                    if (type==11)
+                        {
+                            TH1F* HHF= (TH1F*)(obj);
+                            YODA::Histo1D* dps=YODA::TH1toHisto1D(HHF,_filename);
+                            aos.push_back(dps);
+                        }
+                    if (type==12)
+                        {
+                            TH1D* HHD= (TH1D*)(obj);
+                            YODA::Histo1D* dps=YODA::TH1toHisto1D(HHD);
+                            aos.push_back(dps);
+                        }
+                }
+            if (type==2)   printf("<W> Object %s has unsupported type TH2\n",obj->GetName()) ;
+            if (type==31||type==32||type==33)
+                {
+                    TGraphAsymmErrors* G=(TGraphAsymmErrors*)obj;
+                    Scatter2D* dps = YODA::TGraphtoScatter2D(G,_filename);
+                    aos.push_back(dps);
+                }
+        }
+    fin->Close();
+}
+
+}
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./src/ROOTConvert.cc ./src/ROOTConvert.cc
--- ./src/ROOTConvert.cc	1970-01-01 01:00:00.000000000 +0100
+++ ./src/ROOTConvert.cc	2015-05-20 15:08:19.821396636 +0200
@@ -0,0 +1,233 @@
+// -*- C++ -*-
+//
+// This file is part of YODA -- Yet more Objects for Data Analysis
+// Copyright (C) 2008-2013 The YODA collaboration (see AUTHORS for details)
+//
+#ifndef YODA_ROOTCnv_h
+#define YODA_ROOTCnv_h
+
+#include "YODA/ROOTConvert.h"
+#include "YODA/Histo1D.h"
+#include "YODA/Histo2D.h"
+#include "YODA/Histo1D.h"
+#include "YODA/Profile1D.h"
+#include "YODA/Scatter2D.h"
+
+#include "TH1.h"
+#include "TH2.h"
+#include "TProfile.h"
+#include "TGraphAsymmErrors.h"
+#include "TVectorF.h"
+#include "TFile.h"
+#include "TList.h"
+#include "TKey.h"
+#include "TClass.h"
+#include "TH1F.h"
+#include <string>
+
+namespace YODA
+{
+
+Histo1D* TH1toHisto1D(const TH1* th1, std::string fname)
+{
+    std::vector<HistoBin1D> bins;
+    const TArrayD* sumw2s = th1->GetSumw2();
+    Dbn1D dbn_uflow, dbn_oflow;
+    double sumWtot=0, sumW2tot=0;
+    for (int i = 0; i <= th1->GetNbinsX()+1; ++i)
+        {
+            Dbn1D dbn(static_cast<unsigned long>(th1->GetBinContent(i)), th1->GetBinContent(i), sumw2s->GetAt(i) 
+                      , 0, 0);
+            //th1->GetBinContent(i)*th1->GetBinCenter(i), th1->GetBinContent(i)*sqr(th1->GetBinCenter(i)));
+            if (i == 0) dbn_uflow = dbn;
+            else if (i == th1->GetNbinsX()+1) dbn_oflow = dbn;
+            else bins.push_back(HistoBin1D(std::make_pair(th1->GetBinLowEdge(i), th1->GetBinLowEdge(i+1)), dbn));
+            sumWtot += th1->GetBinContent(i);
+            sumW2tot +=   sumw2s->GetAt(i);
+        }
+    Dbn1D dbn_tot(static_cast<unsigned long>(th1->GetEntries()), sumWtot, sumW2tot, 0, 0);
+
+    Histo1D* rtn =new Histo1D(bins, dbn_tot, dbn_uflow, dbn_oflow,std::string("/")+fname+std::string("/")+th1->GetName(), th1->GetTitle());
+    rtn->setAnnotation("XLabel", th1->GetXaxis()->GetTitle());
+    rtn->setAnnotation("YLabel", th1->GetYaxis()->GetTitle());
+    rtn->setAnnotation("Title", std::string("/")+th1->GetTitle());
+    return rtn;
+}
+
+Scatter2D* TH1toScatter2D(const TH1* th1, std::string fname)
+{
+    Scatter2D* rtn = new Scatter2D(std::string("/")+fname+std::string("/")+th1->GetName());
+    for (int i = 1; i <= th1->GetNbinsX(); ++i)
+        {
+            const double x = th1->GetBinCenter(i);
+            const double exminus = x - th1->GetBinLowEdge(i);
+            const double explus = th1->GetBinLowEdge(i+1) - x;
+            const double width = exminus + explus;
+            rtn->addPoint(x, th1->GetBinContent(i)/width,
+                          exminus, explus,
+                          th1->GetBinErrorLow(i)/width, th1->GetBinErrorUp(i)/width);
+        }
+    rtn->setAnnotation("XLabel", th1->GetXaxis()->GetTitle());
+    rtn->setAnnotation("YLabel", th1->GetYaxis()->GetTitle());
+    rtn->setAnnotation("Title", std::string("/")+th1->GetTitle());
+    return rtn;
+}
+
+
+
+
+Profile1D*         TProfiletoProfile1D(const TProfile* p, std::string fname)
+{
+
+
+    Profile1D* rtn = new Profile1D(std::string("/")+fname+std::string("/")+p->GetName());
+    for (int i = 1; i <= p->GetNbinsX(); ++i)
+        {
+            const double x = p->GetBinCenter(i);
+            const double exminus = x - p->GetBinLowEdge(i);
+            const double explus = p->GetBinLowEdge(i+1) - x;
+            const double width = exminus + explus;
+//FIXME      rtn->addPoint(x, p->GetBinContent(i)/width, exminus, explus,  p->GetBinErrorLow(i)/width, p->GetBinErrorUp(i)/width);
+        }
+    rtn->setAnnotation("XLabel", p->GetXaxis()->GetTitle());
+    rtn->setAnnotation("YLabel", p->GetYaxis()->GetTitle());
+    rtn->setAnnotation("Title", std::string("/")+p->GetTitle());
+    return rtn;
+
+}
+
+
+Scatter2D* TGraphtoScatter2D(const TGraph* g, std::string fname)
+{
+    Scatter2D* rtn = new Scatter2D(std::string("/")+fname+std::string("/")+g->GetName());
+    int i;
+    for (i=0; i<g->GetN()-1; i++)
+        {
+            double x,y;
+            g->GetPoint(i,x,y);
+            rtn->addPoint(x, y,
+                          g->GetErrorXlow(i),
+                          g->GetErrorXhigh(i),
+                          g->GetErrorYlow(i),
+                          g->GetErrorYhigh(i)
+                         );
+        }
+    rtn->addAnnotation("XLabel", g->GetXaxis()->GetTitle());
+    rtn->addAnnotation("YLabel", g->GetYaxis()->GetTitle());
+    rtn->setAnnotation("Title", std::string("/")+g->GetTitle());
+    return rtn;
+}
+
+
+
+TH1D* Histo1DtoTH1D(const Histo1D* h)
+{
+    // Work out bin edges first
+    std::vector<double> edges;
+    edges.reserve(h->numBins()+1);
+    edges.push_back(h->bin(0).xMin());
+    for (size_t i = 0; i < h->numBins(); ++i)
+        {
+            const HistoBin1D& b = h->bin(i);
+            if (!fuzzyEquals(edges.back(), b.xMin())) edges.push_back(b.xMin());
+            if (!fuzzyEquals(edges.back(), b.xMax())) edges.push_back(b.xMax());
+        }
+    // Book ROOT histogram
+    TH1D* rtn= new TH1D(h->path().c_str(), h->title().c_str(), edges.size()-1, &edges[0]);
+    rtn->Sumw2();
+    TArrayD* sumw2s = new TArrayD(*(rtn->GetSumw2()));
+    for (int i = 1; i <= rtn->GetNbinsX(); ++i)
+        {
+            try
+                {
+                    const HistoBin1D& b = h->binAt(rtn->GetBinCenter(i)); // throws if in a gap
+                    rtn->SetBinContent(i, b.sumW());
+                    //FIXME sumw2s[i] = b.sumW2();
+                }
+            catch (const Exception& e) {  }
+        }
+    // Overflows
+    rtn->SetBinContent(0, h->underflow().sumW());
+    rtn->SetBinContent(rtn->GetNbinsX()+1, h->overflow().sumW());
+    //FIXME  sumw2s[0] = h->underflow().sumW2();
+    //FIXME  sumw2s[rtn->GetNbinsX()+1] = h->overflow().sumW2();
+    // Labels
+    if (h->hasAnnotation("XLabel")) rtn->SetXTitle(h->annotation("XLabel").c_str());
+    if (h->hasAnnotation("YLabel")) rtn->SetYTitle(h->annotation("YLabel").c_str());
+
+    return rtn;
+}
+
+
+TProfile* Profile1DtoTProfile(const Profile1D* p)
+{
+    // Work out bin edges first
+    std::vector<double> edges;
+    edges.reserve(p->numBins()+1);
+    edges.push_back(p->bin(0).xMin());
+    for (size_t i = 0; i < p->numBins(); ++i)
+        {
+            const ProfileBin1D& b = p->bin(i);
+            if (!fuzzyEquals(edges.back(), b.xMin())) edges.push_back(b.xMin());
+            if (!fuzzyEquals(edges.back(), b.xMax())) edges.push_back(b.xMax());
+        }
+    // Book ROOT histogram
+    TProfile *rtn =new TProfile(p->path().c_str(), p->title().c_str(), edges.size()-1, &edges[0]);
+    rtn->Sumw2();
+    TArrayD* sumw2s = new TArrayD(*(rtn->GetSumw2()));
+    for (int i = 1; i <= rtn->GetNbinsX(); ++i)
+        {
+            try
+                {
+                    const ProfileBin1D& b = p->binAt(rtn->GetBinCenter(i)); // throws if in a gap
+                    /// @todo This part is probably wrong -- also need to do something with GetW,
+                    ///   GetW2, GetB, GetB2, and/or GetBinSumw2? ROOT docs are 100% useless...
+                    rtn->SetBinContent(i, b.sumW());
+                    //FIXME  sumw2s[i] = b.sumW2();
+                }
+            catch (const Exception& e) {  }
+        }
+    // Overflows
+    rtn->SetBinContent(0, p->underflow().sumW());
+    rtn->SetBinContent(rtn->GetNbinsX()+1, p->overflow().sumW());
+    //FIXME  sumw2s[0] = p->underflow().sumW2();
+    //FIXME  sumw2s[rtn->GetNbinsX()+1] = p->overflow().sumW2();
+    // Labels
+    if (p->hasAnnotation("XLabel")) rtn->SetXTitle(p->annotation("XLabel").c_str());
+    if (p->hasAnnotation("YLabel")) rtn->SetYTitle(p->annotation("YLabel").c_str());
+    return rtn;
+}
+
+
+
+TGraphAsymmErrors* Scatter2DtoTGraphAsymmErrors(const Scatter2D* s)
+{
+    TVectorF xs(s->numPoints()), ys(s->numPoints());
+    TVectorF exls(s->numPoints()), exhs(s->numPoints());
+    TVectorF eyls(s->numPoints()), eyhs(s->numPoints());
+    for (size_t i = 0; i < s->numPoints(); ++i)
+        {
+            const Point2D& p = s->point(i);
+            xs[i] = p.x();
+            ys[i] = p.y();
+            exls[i] = p.xErrMinus();
+            exhs[i] = p.xErrPlus();
+            eyls[i] = p.yErrMinus();
+            eyhs[i] = p.yErrPlus();
+        }
+    // Make the ROOT object... mm, the constructors don't take name+title, unlike all this histos!
+    TGraphAsymmErrors* rtn= new TGraphAsymmErrors(xs, ys, exls, exhs, eyls, eyhs);
+    rtn->SetName(s->path().c_str());
+    rtn->SetTitle(s->title().c_str());
+    // Labels
+    if (s->hasAnnotation("XLabel")) rtn->GetXaxis()->SetTitle(s->annotation("XLabel").c_str());
+    if (s->hasAnnotation("YLabel")) rtn->GetYaxis()->SetTitle(s->annotation("YLabel").c_str());
+    return rtn;
+}
+
+//@}
+
+
+}
+
+#endif
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./src/Writer.cc ./src/Writer.cc
--- ./src/Writer.cc	2015-05-20 15:08:19.017373990 +0200
+++ ./src/Writer.cc	2015-05-20 15:08:19.825396749 +0200
@@ -1,12 +1,15 @@
 // -*- C++ -*-
 //
 // This file is part of YODA -- Yet more Objects for Data Analysis
-// Copyright (C) 2008-2015 The YODA collaboration (see AUTHORS for details)
+// Copyright (C) 2008-2014 The YODA collaboration (see AUTHORS for details)
 //
 #include "YODA/Writer.h"
 #include "YODA/WriterYODA.h"
 #include "YODA/WriterAIDA.h"
 #include "YODA/WriterFLAT.h"
+#ifdef ENABLE_ROOT
+#include "YODA/WriterROOT.h"
+#endif
 #include "boost/algorithm/string.hpp"
 #include <iostream>
 #include <typeinfo>
@@ -23,7 +26,10 @@
     // cout << "File extension: " << fmt << endl;
     if (fmt == "yoda") return WriterYODA::create();
     if (fmt == "aida") return WriterAIDA::create();
-    if (fmt == "dat" || fmt == "flat") return WriterFLAT::create();
+    if (fmt == "flat") return WriterFLAT::create();
+#ifdef ENABLE_ROOT
+    if (fmt == "root") return WriterROOT::create(name);
+#endif
     throw UserError("Format cannot be identified from string '" + name + "'");
   }
 
diff -Naur -x '*svn*' -x '*Makefile.in*' -x 'acloc*' ./src/WriterROOT.cc ./src/WriterROOT.cc
--- ./src/WriterROOT.cc	1970-01-01 01:00:00.000000000 +0100
+++ ./src/WriterROOT.cc	2015-05-20 15:08:19.825396749 +0200
@@ -0,0 +1,69 @@
+// -*- C++ -*-
+//
+// This file is part of YODA -- Yet more Objects for Data Analysis
+// Copyright (C) 2008-2013 The YODA collaboration (see AUTHORS for details)
+//
+#include "YODA/WriterROOT.h"
+
+#include "YODA/Histo1D.h"
+#include "YODA/Histo2D.h"
+#include "YODA/Profile1D.h"
+#include "YODA/Scatter2D.h"
+#include "YODA/ROOTConvert.h"
+#include <iostream>
+#include <iomanip>
+
+using namespace std;
+
+namespace YODA
+{
+
+
+void WriterROOT::writeHeader(std::ostream& os) {}
+void WriterROOT::writeFooter(std::ostream& os) {}
+void WriterROOT::_writeAnnotations(std::ostream& os, const AnalysisObject& ao) { }
+void WriterROOT::writeCounter(std::ostream& os, const Counter& c) { }
+
+void WriterROOT::writeHisto1D(std::ostream& os, const Histo1D& h)
+{
+    if (_ROOTfile) _ROOTfile->cd();
+    else printf("No output ROOT file %s\n",_filename.c_str());
+    TH1D* dps=YODA::Histo1DtoTH1D(&h);
+    if (dps) {  dps->SetDirectory(_ROOTfile); dps->Write( ); dps->SetDirectory(0);}
+}
+
+
+void WriterROOT::writeHisto2D(std::ostream& os, const Histo2D& h) { }
+
+void WriterROOT::writeProfile1D(std::ostream& os, const Profile1D& p)
+{
+    if (_ROOTfile) _ROOTfile->cd();
+    else printf("No output ROOT file %s\n",_filename.c_str());
+    TProfile* dps=YODA::Profile1DtoTProfile(&p);
+    if (dps) { dps->SetDirectory(_ROOTfile); dps->Write(); dps->SetDirectory(0);}
+}
+
+void WriterROOT::writeScatter2D(std::ostream& os, const Scatter2D& s)
+{
+    if (_ROOTfile) _ROOTfile->cd();
+    else printf("No output ROOT file %s\n",_filename.c_str());
+    TGraphAsymmErrors* dps=YODA::Scatter2DtoTGraphAsymmErrors(&s);
+    if (dps)
+        {
+            _ROOTfile->Append(dps),  dps->Write();
+            //dps->SetDirectory(0);
+        }
+    //dps->SetDirectory(0);
+}
+
+
+     void WriterROOT::writeProfile2D(std::ostream& stream, const Profile2D& p){};
+    void WriterROOT::writeScatter1D(std::ostream& stream, const Scatter1D& s){};
+
+     void WriterROOT::writeScatter3D(std::ostream& stream, const Scatter3D& s){};
+
+
+
+
+
+}
